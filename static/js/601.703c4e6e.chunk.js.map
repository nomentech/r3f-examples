{"version":3,"file":"static/js/601.703c4e6e.chunk.js","mappings":"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","sources":["basic-examples/grass-shader/GrassMaterial.tsx","basic-examples/grass-shader/Grass.tsx","basic-examples/grass-shader/Example.tsx"],"sourcesContent":["import * as THREE from \"three\"\nimport { shaderMaterial } from \"@react-three/drei\"\nimport { extend, Object3DNode } from \"@react-three/fiber\"\n\nconst GrassMaterial = shaderMaterial(\n  {\n    bladeHeight: 1,\n    map: null,\n    alphaMap: null,\n    time: 0,\n    tipColor: new THREE.Color(0.0, 0.6, 0.0).convertSRGBToLinear(),\n    bottomColor: new THREE.Color(0.0, 0.1, 0.0).convertSRGBToLinear(),\n  },\n  `   precision mediump float;\n      attribute vec3 offset;\n      attribute vec4 orientation;\n      attribute float halfRootAngleSin;\n      attribute float halfRootAngleCos;\n      attribute float stretch;\n      uniform float time;\n      uniform float bladeHeight;\n      varying vec2 vUv;\n      varying float frc;\n      \n      //WEBGL-NOISE FROM https://github.com/stegu/webgl-noise\n      //Description : Array and textureless GLSL 2D simplex noise function. Author : Ian McEwan, Ashima Arts. Maintainer : stegu Lastmod : 20110822 (ijm) License : Copyright (C) 2011 Ashima Arts. All rights reserved. Distributed under the MIT License. See LICENSE file. https://github.com/ashima/webgl-noise https://github.com/stegu/webgl-noise      \n      vec3 mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;} vec2 mod289(vec2 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;} vec3 permute(vec3 x) {return mod289(((x*34.0)+1.0)*x);} float snoise(vec2 v){const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439); vec2 i  = floor(v + dot(v, C.yy) ); vec2 x0 = v -   i + dot(i, C.xx); vec2 i1; i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); vec4 x12 = x0.xyxy + C.xxzz; x12.xy -= i1; i = mod289(i); vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 )); vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0); m = m*m ; m = m*m ; vec3 x = 2.0 * fract(p * C.www) - 1.0; vec3 h = abs(x) - 0.5; vec3 ox = floor(x + 0.5); vec3 a0 = x - ox; m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h ); vec3 g; g.x  = a0.x  * x0.x  + h.x  * x0.y; g.yz = a0.yz * x12.xz + h.yz * x12.yw; return 130.0 * dot(m, g);}\n      //END NOISE\n      \n      //https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/\n      vec3 rotateVectorByQuaternion( vec3 v, vec4 q){\n        return 2.0 * cross(q.xyz, v * q.w + cross(q.xyz, v)) + v;\n      }\n      \n      //https://en.wikipedia.org/wiki/Slerp\n      vec4 slerp(vec4 v0, vec4 v1, float t) {\n        // Only unit quaternions are valid rotations.\n        // Normalize to avoid undefined behavior.\n        normalize(v0);\n        normalize(v1);\n      \n        // Compute the cosine of the angle between the two vectors.\n        float dot_ = dot(v0, v1);\n      \n        // If the dot product is negative, slerp won't take\n        // the shorter path. Note that v1 and -v1 are equivalent when\n        // the negation is applied to all four components. Fix by \n        // reversing one quaternion.\n        if (dot_ < 0.0) {\n          v1 = -v1;\n          dot_ = -dot_;\n        }  \n      \n        const float DOT_THRESHOLD = 0.9995;\n        if (dot_ > DOT_THRESHOLD) {\n          // If the inputs are too close for comfort, linearly interpolate\n          // and normalize the result.\n          vec4 result = t*(v1 - v0) + v0;\n          normalize(result);\n          return result;\n        }\n      \n        // Since dot is in range [0, DOT_THRESHOLD], acos is safe\n        float theta_0 = acos(dot_);       // theta_0 = angle between input vectors\n        float theta = theta_0*t;          // theta = angle between v0 and result\n        float sin_theta = sin(theta);     // compute this value only once\n        float sin_theta_0 = sin(theta_0); // compute this value only once\n        float s0 = cos(theta) - dot_ * sin_theta / sin_theta_0;  // == sin(theta_0 - theta) / sin(theta_0)\n        float s1 = sin_theta / sin_theta_0;\n        return (s0 * v0) + (s1 * v1);\n      }\n      \n      void main() {\n        //Relative position of vertex along the mesh Y direction\n        frc = position.y/float(bladeHeight);\n        //Get wind data from simplex noise \n        float noise = 1.0-(snoise(vec2((time-offset.x/50.0), (time-offset.z/50.0)))); \n        //Define the direction of an unbent blade of grass rotated around the Y axis\n        vec4 direction = vec4(0.0, halfRootAngleSin, 0.0, halfRootAngleCos);\n        //Interpolate between the unbent direction and the direction of growth calculated on the CPU. \n        //Using the relative location of the vertex along the Y axis as the weight, we get a smooth bend\n        direction = slerp(direction, orientation, frc);\n        vec3 vPosition = vec3(position.x, position.y + position.y * stretch, position.z);\n        vPosition = rotateVectorByQuaternion(vPosition, direction);\n      \n       //Apply wind\n       float halfAngle = noise * 0.15;\n        vPosition = rotateVectorByQuaternion(vPosition, normalize(vec4(sin(halfAngle), 0.0, -sin(halfAngle), cos(halfAngle))));\n        //UV for texture\n        vUv = uv;\n        //Calculate final position of the vertex from the world offset and the above shenanigans \n        gl_Position = projectionMatrix * modelViewMatrix * vec4(offset + vPosition, 1.0 );\n      }`,\n  `\n      precision mediump float;\n      uniform sampler2D map;\n      uniform sampler2D alphaMap;\n      uniform vec3 tipColor;\n      uniform vec3 bottomColor;\n      varying vec2 vUv;\n      varying float frc;\n      \n      void main() {\n        //Get transparency information from alpha map\n        float alpha = texture2D(alphaMap, vUv).r;\n        //If transparent, don't draw\n        if(alpha < 0.15) discard;\n        //Get colour data from texture\n        vec4 col = vec4(texture2D(map, vUv));\n        //Add more green towards root\n        col = mix(vec4(tipColor, 1.0), col, frc);\n        //Add a shadow towards root\n        col = mix(vec4(bottomColor, 1.0), col, frc);\n        gl_FragColor = col;\n\n        #include <tonemapping_fragment>\n\t      #include <encodings_fragment>\n      }`,\n  (self: any) => {\n    self.side = THREE.DoubleSide\n  },\n)\n\nextend({ GrassMaterial })\n\ndeclare global {\n  namespace JSX {\n    interface IntrinsicElements {\n      grassMaterial: Object3DNode<any, typeof GrassMaterial>\n    }\n  }\n}\n","import { useMemo, useRef } from 'react'\nimport * as THREE from 'three'\nimport { Geometry } from \"three/examples/jsm/deprecated/Geometry\"\nimport { useFrame, useLoader } from '@react-three/fiber'\nimport SimplexNoise from 'simplex-noise'\n\nimport bladeDiffuse from '../../textures/blade_diffuse.jpg'\nimport bladeAlpha from '../../textures/blade_alpha.jpg'\nimport './GrassMaterial'\n\nconst simplex = new SimplexNoise(Math.random)\n\nconst Grass = ({ options = { bW: 0.12, bH: 1, joints: 5 }, width = 100, instances = 50000, ...props }) => {\n  const { bW, bH, joints } = options\n  const materialRef: any = useRef()\n  const [texture, alphaMap] = useLoader(THREE.TextureLoader, [bladeDiffuse, bladeAlpha])\n  const attributeData = useMemo(() => getAttributeData(instances, width), [instances, width])\n  const baseGeom = useMemo(() => new THREE.PlaneBufferGeometry(bW, bH, 1, joints).translate(0, bH/2, 0), [options])\n  const groundGeo = useMemo(() => {\n    const geo = new Geometry().fromBufferGeometry(new THREE.PlaneBufferGeometry(width, width, 32, 32))\n    geo.verticesNeedUpdate = true\n    geo.lookAt(new THREE.Vector3(0, 1, 0))\n    for (let i=0; i<geo.vertices.length; i++) {\n      const v = geo.vertices[i]\n      v.y = getYPosition(v.x, v.z)\n    }\n    geo.computeVertexNormals()\n    return geo.toBufferGeometry()\n  }, [width])\n  useFrame((state) => (materialRef.current.uniforms.time.value = state.clock.elapsedTime / 4))\n\n  return (\n    <group {...props}>\n      <mesh>\n        <instancedBufferGeometry index={baseGeom.index} attributes-position={baseGeom.attributes.position} attributes-uv={baseGeom.attributes.uv}>\n        <instancedBufferAttribute attach=\"attributes-offset\" args={[new Float32Array(attributeData.offsets), 3]} />\n          <instancedBufferAttribute attach=\"attributes-orientation\" args={[new Float32Array(attributeData.orientations), 4]} />\n          <instancedBufferAttribute attach=\"attributes-stretch\" args={[new Float32Array(attributeData.stretches), 1]} />\n          <instancedBufferAttribute attach=\"attributes-halfRootAngleSin\" args={[new Float32Array(attributeData.halfRootAngleSin), 1]} />\n          <instancedBufferAttribute attach=\"attributes-halfRootAngleCos\" args={[new Float32Array(attributeData.halfRootAngleCos), 1]} />\n        </instancedBufferGeometry>\n        <grassMaterial ref={materialRef} map={texture} alphaMap={alphaMap} toneMapped={false} />\n      </mesh>\n      <mesh position={[0, 0, 0]} geometry={groundGeo}>\n        <meshStandardMaterial color='#000f00' />\n      </mesh>\n    </group>\n  )\n}\n\nfunction getAttributeData(instances: number, width: number) {\n  const offsets = []\n  const orientations = []\n  const stretches = []\n  const halfRootAngleSin = []\n  const halfRootAngleCos = []\n\n  let quaternion_0 = new THREE.Vector4()\n  let quaternion_1 = new THREE.Vector4()\n\n  //The min and max angle for the growth direction (in radians)\n  const min = -0.25\n  const max = 0.25\n\n  //For each instance of the grass blade\n  for (let i = 0; i < instances; i++) {\n    //Offset of the roots\n    const offsetX = Math.random() * width - width / 2\n    const offsetZ = Math.random() * width - width / 2\n    const offsetY = getYPosition(offsetX, offsetZ)\n    offsets.push(offsetX, offsetY, offsetZ)\n\n    //Define random growth directions\n    //Rotate around Y\n    let angle = Math.PI - Math.random() * (2 * Math.PI)\n    halfRootAngleSin.push(Math.sin(0.5 * angle))\n    halfRootAngleCos.push(Math.cos(0.5 * angle))\n\n    let RotationAxis = new THREE.Vector3(0, 1, 0)\n    let x = RotationAxis.x * Math.sin(angle / 2.0)\n    let y = RotationAxis.y * Math.sin(angle / 2.0)\n    let z = RotationAxis.z * Math.sin(angle / 2.0)\n    let w = Math.cos(angle / 2.0)\n    quaternion_0.set(x, y, z, w).normalize()\n\n    //Rotate around X\n    angle = Math.random() * (max - min) + min\n    RotationAxis = new THREE.Vector3(1, 0, 0)\n    x = RotationAxis.x * Math.sin(angle / 2.0)\n    y = RotationAxis.y * Math.sin(angle / 2.0)\n    z = RotationAxis.z * Math.sin(angle / 2.0)\n    w = Math.cos(angle / 2.0)\n    quaternion_1.set(x, y, z, w).normalize()\n\n    //Combine rotations to a single quaternion\n    quaternion_0 = multiplyQuaternions(quaternion_0, quaternion_1)\n\n    //Rotate around Z\n    angle = Math.random() * (max - min) + min\n    RotationAxis = new THREE.Vector3(0, 0, 1)\n    x = RotationAxis.x * Math.sin(angle / 2.0)\n    y = RotationAxis.y * Math.sin(angle / 2.0)\n    z = RotationAxis.z * Math.sin(angle / 2.0)\n    w = Math.cos(angle / 2.0)\n    quaternion_1.set(x, y, z, w).normalize()\n\n    //Combine rotations to a single quaternion\n    quaternion_0 = multiplyQuaternions(quaternion_0, quaternion_1)\n\n    orientations.push(quaternion_0.x, quaternion_0.y, quaternion_0.z, quaternion_0.w)\n\n    //Define variety in height\n    if (i < instances / 3) {\n      stretches.push(Math.random() * 1.8)\n    } else {\n      stretches.push(Math.random())\n    }\n  }\n\n  return {\n    offsets,\n    orientations,\n    stretches,\n    halfRootAngleCos,\n    halfRootAngleSin,\n  }\n}\n\nfunction multiplyQuaternions(q1: THREE.Vector4, q2: THREE.Vector4) {\n  const x = q1.x * q2.w + q1.y * q2.z - q1.z * q2.y + q1.w * q2.x\n  const y = -q1.x * q2.z + q1.y * q2.w + q1.z * q2.x + q1.w * q2.y\n  const z = q1.x * q2.y - q1.y * q2.x + q1.z * q2.w + q1.w * q2.z\n  const w = -q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w\n  return new THREE.Vector4(x, y, z, w)\n}\n\nfunction getYPosition(x: number, z: number) {\n  var y = 2 * simplex.noise2D(x / 50, z / 50)\n  y += 4 * simplex.noise2D(x / 100, z / 100)\n  y += 0.2 * simplex.noise2D(x / 10, z / 10)\n  return y\n}\n\nexport default Grass","import { Suspense } from 'react'\nimport { Canvas } from '@react-three/fiber'\nimport { OrbitControls, Sky } from '@react-three/drei'\n\nimport Grass from './Grass'\n\nconst Example = ({ children }: any) => {\n  return (\n    <>\n      { children }\n      <Canvas camera={{ position: [15, 15, 10] }}>\n        <Sky azimuth={1} inclination={0.6} distance={1000} />\n        <ambientLight />\n        <pointLight position={[10, 10, 10]} />\n        <Suspense fallback={null}>\n          <Grass />\n        </Suspense>\n        <OrbitControls minPolarAngle={Math.PI / 2.5} maxPolarAngle={Math.PI / 2.5} />\n      </Canvas>\n    </>\n  )\n}\n\nexport default Example"],"names":["GrassMaterial","shaderMaterial","bladeHeight","map","alphaMap","time","tipColor","THREE","convertSRGBToLinear","bottomColor","self","side","extend","simplex","SimplexNoise","Math","random","multiplyQuaternions","q1","q2","x","w","y","z","getYPosition","noise2D","options","bW","bH","joints","width","instances","props","materialRef","useRef","useLoader","bladeDiffuse","bladeAlpha","texture","attributeData","useMemo","offsets","orientations","stretches","halfRootAngleSin","halfRootAngleCos","quaternion_0","quaternion_1","min","max","i","offsetX","offsetZ","offsetY","push","angle","PI","sin","cos","RotationAxis","set","normalize","getAttributeData","baseGeom","translate","groundGeo","geo","Geometry","fromBufferGeometry","verticesNeedUpdate","lookAt","vertices","length","v","computeVertexNormals","toBufferGeometry","useFrame","state","current","uniforms","value","clock","elapsedTime","index","attributes","position","uv","attach","args","Float32Array","ref","toneMapped","geometry","color","children","camera","Sky","azimuth","inclination","distance","Suspense","fallback","OrbitControls","minPolarAngle","maxPolarAngle"],"sourceRoot":""}