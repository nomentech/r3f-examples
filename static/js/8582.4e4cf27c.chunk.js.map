{"version":3,"file":"static/js/8582.4e4cf27c.chunk.js","mappings":"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","sources":["../node_modules/@react-three/drei/core/MapControls.js","../node_modules/three/examples/jsm/loaders/SVGLoader.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport * as React from 'react';\nimport { MapControls as MapControls$1 } from 'three-stdlib';\n\nconst MapControls = /*#__PURE__*/React.forwardRef((props = {\n  enableDamping: true\n}, ref) => {\n  const {\n    domElement,\n    camera,\n    onChange,\n    onStart,\n    onEnd,\n    ...rest\n  } = props;\n  const invalidate = useThree(state => state.invalidate);\n  const defaultCamera = useThree(state => state.camera);\n  const gl = useThree(state => state.gl);\n  const events = useThree(state => state.events);\n  const explDomElement = domElement || events.connected || gl.domElement;\n  const explCamera = camera || defaultCamera;\n  const controls = React.useMemo(() => new MapControls$1(explCamera), [explCamera]);\n  React.useEffect(() => {\n    controls.connect(explDomElement);\n\n    const callback = e => {\n      invalidate();\n      if (onChange) onChange(e);\n    };\n\n    controls.addEventListener('change', callback);\n    if (onStart) controls.addEventListener('start', onStart);\n    if (onEnd) controls.addEventListener('end', onEnd);\n    return () => {\n      controls.dispose();\n      controls.removeEventListener('change', callback);\n      if (onStart) controls.removeEventListener('start', onStart);\n      if (onEnd) controls.removeEventListener('end', onEnd);\n    };\n  }, [onChange, onStart, onEnd, controls, invalidate, explDomElement]);\n  useFrame(() => controls.update(), -1);\n  return /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    ref: ref,\n    object: controls,\n    enableDamping: true\n  }, rest));\n});\n\nexport { MapControls };\n","import {\n\tBox2,\n\tBufferGeometry,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tLoader,\n\tMatrix3,\n\tPath,\n\tShape,\n\tShapePath,\n\tShapeUtils,\n\tVector2,\n\tVector3\n} from 'three';\n\nclass SVGLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t// Default dots per inch\n\t\tthis.defaultDPI = 90;\n\n\t\t// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\t\tthis.defaultUnit = 'px';\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( text ) {\n\n\t\tconst scope = this;\n\n\t\tfunction parseNode( node, style ) {\n\n\t\t\tif ( node.nodeType !== 1 ) return;\n\n\t\t\tconst transform = getNodeTransform( node );\n\n\t\t\tlet isDefsNode = false;\n\n\t\t\tlet path = null;\n\n\t\t\tswitch ( node.nodeName ) {\n\n\t\t\t\tcase 'svg':\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'style':\n\t\t\t\t\tparseCSSStylesheet( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'g':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'path':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tif ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rect':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseRectNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polygon':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolygonNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polyline':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolylineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'circle':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseCircleNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ellipse':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseEllipseNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'line':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseLineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'defs':\n\t\t\t\t\tisDefsNode = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'use':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\n\t\t\t\t\tconst href = node.getAttributeNS( 'http://www.w3.org/1999/xlink', 'href' ) || '';\n\t\t\t\t\tconst usedNodeId = href.substring( 1 );\n\t\t\t\t\tconst usedNode = node.viewportElement.getElementById( usedNodeId );\n\t\t\t\t\tif ( usedNode ) {\n\n\t\t\t\t\t\tparseNode( usedNode, style );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'SVGLoader: \\'use node\\' references non-existent node id: ' + usedNodeId );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t// console.log( node );\n\n\t\t\t}\n\n\t\t\tif ( path ) {\n\n\t\t\t\tif ( style.fill !== undefined && style.fill !== 'none' ) {\n\n\t\t\t\t\tpath.color.setStyle( style.fill );\n\n\t\t\t\t}\n\n\t\t\t\ttransformPath( path, currentTransform );\n\n\t\t\t\tpaths.push( path );\n\n\t\t\t\tpath.userData = { node: node, style: style };\n\n\t\t\t}\n\n\t\t\tconst childNodes = node.childNodes;\n\n\t\t\tfor ( let i = 0; i < childNodes.length; i ++ ) {\n\n\t\t\t\tconst node = childNodes[ i ];\n\n\t\t\t\tif ( isDefsNode && node.nodeName !== 'style' && node.nodeName !== 'defs' ) {\n\n\t\t\t\t\t// Ignore everything in defs except CSS style definitions\n\t\t\t\t\t// and nested defs, because it is OK by the standard to have\n\t\t\t\t\t// <style/> there.\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tparseNode( node, style );\n\n\t\t\t}\n\n\n\t\t\tif ( transform ) {\n\n\t\t\t\ttransformStack.pop();\n\n\t\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\t\tcurrentTransform.copy( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePathNode( node ) {\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tconst point = new Vector2();\n\t\t\tconst control = new Vector2();\n\n\t\t\tconst firstPoint = new Vector2();\n\t\t\tlet isFirstPoint = true;\n\t\t\tlet doSetFirstPoint = false;\n\n\t\t\tconst d = node.getAttribute( 'd' );\n\n\t\t\t// console.log( d );\n\n\t\t\tconst commands = d.match( /[a-df-z][^a-df-z]*/ig );\n\n\t\t\tfor ( let i = 0, l = commands.length; i < l; i ++ ) {\n\n\t\t\t\tconst command = commands[ i ];\n\n\t\t\t\tconst type = command.charAt( 0 );\n\t\t\t\tconst data = command.slice( 1 ).trim();\n\n\t\t\t\tif ( isFirstPoint === true ) {\n\n\t\t\t\t\tdoSetFirstPoint = true;\n\t\t\t\t\tisFirstPoint = false;\n\n\t\t\t\t}\n\n\t\t\t\tlet numbers;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'A':\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if start point == end point\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == point.x && numbers[ j + 6 ] == point.y ) continue;\n\n\t\t\t\t\t\t\tconst start = point.clone();\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if no displacement\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == 0 && numbers[ j + 6 ] == 0 ) continue;\n\n\t\t\t\t\t\t\tconst start = point.clone();\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\n\n\t\t\t\t\t\t\t// Reset point to beginning of Path\n\t\t\t\t\t\t\tpoint.copy( firstPoint );\n\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\n\t\t\t\t\t\t\tisFirstPoint = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( command );\n\n\t\t\t\t}\n\n\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\t\t\t\tdoSetFirstPoint = false;\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCSSStylesheet( node ) {\n\n\t\t\tif ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return;\n\n\t\t\tfor ( let i = 0; i < node.sheet.cssRules.length; i ++ ) {\n\n\t\t\t\tconst stylesheet = node.sheet.cssRules[ i ];\n\n\t\t\t\tif ( stylesheet.type !== 1 ) continue;\n\n\t\t\t\tconst selectorList = stylesheet.selectorText\n\t\t\t\t\t.split( /,/gm )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( let j = 0; j < selectorList.length; j ++ ) {\n\n\t\t\t\t\t// Remove empty rules\n\t\t\t\t\tconst definitions = Object.fromEntries(\n\t\t\t\t\t\tObject.entries( stylesheet.style ).filter( ( [ , v ] ) => v !== '' )\n\t\t\t\t\t);\n\n\t\t\t\t\tstylesheets[ selectorList[ j ] ] = Object.assign(\n\t\t\t\t\t\tstylesheets[ selectorList[ j ] ] || {},\n\t\t\t\t\t\tdefinitions\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n\t\t * From\n\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n\t\t * To\n\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n\t\t */\n\n\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\n\n\t\t\tif ( rx == 0 || ry == 0 ) {\n\n\t\t\t\t// draw a line if either of the radii == 0\n\t\t\t\tpath.lineTo( end.x, end.y );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\n\n\t\t\t// Ensure radii are positive\n\t\t\trx = Math.abs( rx );\n\t\t\try = Math.abs( ry );\n\n\t\t\t// Compute (x1', y1')\n\t\t\tconst dx2 = ( start.x - end.x ) / 2.0;\n\t\t\tconst dy2 = ( start.y - end.y ) / 2.0;\n\t\t\tconst x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\n\t\t\tconst y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\n\n\t\t\t// Compute (cx', cy')\n\t\t\tlet rxs = rx * rx;\n\t\t\tlet rys = ry * ry;\n\t\t\tconst x1ps = x1p * x1p;\n\t\t\tconst y1ps = y1p * y1p;\n\n\t\t\t// Ensure radii are large enough\n\t\t\tconst cr = x1ps / rxs + y1ps / rys;\n\n\t\t\tif ( cr > 1 ) {\n\n\t\t\t\t// scale up rx,ry equally so cr == 1\n\t\t\t\tconst s = Math.sqrt( cr );\n\t\t\t\trx = s * rx;\n\t\t\t\try = s * ry;\n\t\t\t\trxs = rx * rx;\n\t\t\t\trys = ry * ry;\n\n\t\t\t}\n\n\t\t\tconst dq = ( rxs * y1ps + rys * x1ps );\n\t\t\tconst pq = ( rxs * rys - dq ) / dq;\n\t\t\tlet q = Math.sqrt( Math.max( 0, pq ) );\n\t\t\tif ( large_arc_flag === sweep_flag ) q = - q;\n\t\t\tconst cxp = q * rx * y1p / ry;\n\t\t\tconst cyp = - q * ry * x1p / rx;\n\n\t\t\t// Step 3: Compute (cx, cy) from (cx', cy')\n\t\t\tconst cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\n\t\t\tconst cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\n\n\t\t\t// Step 4: Compute θ1 and Δθ\n\t\t\tconst theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\n\t\t\tconst delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\n\n\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\n\n\t\t}\n\n\t\tfunction svgAngle( ux, uy, vx, vy ) {\n\n\t\t\tconst dot = ux * vx + uy * vy;\n\t\t\tconst len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\n\t\t\tlet ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\n\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\n\t\t\treturn ang;\n\n\t\t}\n\n\t\t/*\n\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n\t\t*/\n\t\tfunction parseRectNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || node.getAttribute( 'ry' ) || 0 );\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || node.getAttribute( 'rx' ) || 0 );\n\t\t\tconst w = parseFloatWithUnits( node.getAttribute( 'width' ) );\n\t\t\tconst h = parseFloatWithUnits( node.getAttribute( 'height' ) );\n\n\t\t\t// Ellipse arc to Bezier approximation Coefficient (Inversed). See:\n\t\t\t// https://spencermortensen.com/articles/bezier-circle/\n\t\t\tconst bci = 1 - 0.551915024494;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\t// top left\n\t\t\tpath.moveTo( x + rx, y );\n\n\t\t\t// top right\n\t\t\tpath.lineTo( x + w - rx, y );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + w - rx * bci,\n\t\t\t\t\ty,\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + ry * bci,\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + ry\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// bottom right\n\t\t\tpath.lineTo( x + w, y + h - ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + h - ry * bci,\n\t\t\t\t\tx + w - rx * bci,\n\t\t\t\t\ty + h,\n\t\t\t\t\tx + w - rx,\n\t\t\t\t\ty + h\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// bottom left\n\t\t\tpath.lineTo( x + rx, y + h );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + rx * bci,\n\t\t\t\t\ty + h,\n\t\t\t\t\tx,\n\t\t\t\t\ty + h - ry * bci,\n\t\t\t\t\tx,\n\t\t\t\t\ty + h - ry\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// back to top left\n\t\t\tpath.lineTo( x, y + ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y + ry * bci, x + rx * bci, y, x + rx, y );\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolygonNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tconst x = parseFloatWithUnits( a );\n\t\t\t\tconst y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tconst regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tlet index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolylineNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tconst x = parseFloatWithUnits( a );\n\t\t\t\tconst y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tconst regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tlet index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCircleNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\n\t\t\tconst r = parseFloatWithUnits( node.getAttribute( 'r' ) || 0 );\n\n\t\t\tconst subpath = new Path();\n\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseEllipseNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );\n\n\t\t\tconst subpath = new Path();\n\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseLineNode( node ) {\n\n\t\t\tconst x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) || 0 );\n\t\t\tconst y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) || 0 );\n\t\t\tconst x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) || 0 );\n\t\t\tconst y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) || 0 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.moveTo( x1, y1 );\n\t\t\tpath.lineTo( x2, y2 );\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction parseStyle( node, style ) {\n\n\t\t\tstyle = Object.assign( {}, style ); // clone style\n\n\t\t\tlet stylesheetStyles = {};\n\n\t\t\tif ( node.hasAttribute( 'class' ) ) {\n\n\t\t\t\tconst classSelectors = node.getAttribute( 'class' )\n\t\t\t\t\t.split( /\\s/ )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( let i = 0; i < classSelectors.length; i ++ ) {\n\n\t\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'id' ) ) {\n\n\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] );\n\n\t\t\t}\n\n\t\t\tfunction addStyle( svgName, jsName, adjustFunction ) {\n\n\t\t\t\tif ( adjustFunction === undefined ) adjustFunction = function copy( v ) {\n\n\t\t\t\t\tif ( v.startsWith( 'url' ) ) console.warn( 'SVGLoader: url access in attributes is not implemented.' );\n\n\t\t\t\t\treturn v;\n\n\t\t\t\t};\n\n\t\t\t\tif ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );\n\t\t\t\tif ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] );\n\t\t\t\tif ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );\n\n\t\t\t}\n\n\t\t\tfunction clamp( v ) {\n\n\t\t\t\treturn Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );\n\n\t\t\t}\n\n\t\t\tfunction positive( v ) {\n\n\t\t\t\treturn Math.max( 0, parseFloatWithUnits( v ) );\n\n\t\t\t}\n\n\t\t\taddStyle( 'fill', 'fill' );\n\t\t\taddStyle( 'fill-opacity', 'fillOpacity', clamp );\n\t\t\taddStyle( 'fill-rule', 'fillRule' );\n\t\t\taddStyle( 'opacity', 'opacity', clamp );\n\t\t\taddStyle( 'stroke', 'stroke' );\n\t\t\taddStyle( 'stroke-opacity', 'strokeOpacity', clamp );\n\t\t\taddStyle( 'stroke-width', 'strokeWidth', positive );\n\t\t\taddStyle( 'stroke-linejoin', 'strokeLineJoin' );\n\t\t\taddStyle( 'stroke-linecap', 'strokeLineCap' );\n\t\t\taddStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );\n\t\t\taddStyle( 'visibility', 'visibility' );\n\n\t\t\treturn style;\n\n\t\t}\n\n\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\t\tfunction getReflection( a, b ) {\n\n\t\t\treturn a - ( b - a );\n\n\t\t}\n\n\t\t// from https://github.com/ppvg/svg-numbers (MIT License)\n\n\t\tfunction parseFloats( input, flags, stride ) {\n\n\t\t\tif ( typeof input !== 'string' ) {\n\n\t\t\t\tthrow new TypeError( 'Invalid input: ' + typeof input );\n\n\t\t\t}\n\n\t\t\t// Character groups\n\t\t\tconst RE = {\n\t\t\t\tSEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n\t\t\t\tWHITESPACE: /[ \\t\\r\\n]/,\n\t\t\t\tDIGIT: /[\\d]/,\n\t\t\t\tSIGN: /[-+]/,\n\t\t\t\tPOINT: /\\./,\n\t\t\t\tCOMMA: /,/,\n\t\t\t\tEXP: /e/i,\n\t\t\t\tFLAGS: /[01]/\n\t\t\t};\n\n\t\t\t// States\n\t\t\tconst SEP = 0;\n\t\t\tconst INT = 1;\n\t\t\tconst FLOAT = 2;\n\t\t\tconst EXP = 3;\n\n\t\t\tlet state = SEP;\n\t\t\tlet seenComma = true;\n\t\t\tlet number = '', exponent = '';\n\t\t\tconst result = [];\n\n\t\t\tfunction throwSyntaxError( current, i, partial ) {\n\n\t\t\t\tconst error = new SyntaxError( 'Unexpected character \"' + current + '\" at index ' + i + '.' );\n\t\t\t\terror.partial = partial;\n\t\t\t\tthrow error;\n\n\t\t\t}\n\n\t\t\tfunction newNumber() {\n\n\t\t\t\tif ( number !== '' ) {\n\n\t\t\t\t\tif ( exponent === '' ) result.push( Number( number ) );\n\t\t\t\t\telse result.push( Number( number ) * Math.pow( 10, Number( exponent ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tnumber = '';\n\t\t\t\texponent = '';\n\n\t\t\t}\n\n\t\t\tlet current;\n\t\t\tconst length = input.length;\n\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\tcurrent = input[ i ];\n\n\t\t\t\t// check for flags\n\t\t\t\tif ( Array.isArray( flags ) && flags.includes( result.length % stride ) && RE.FLAGS.test( current ) ) {\n\n\t\t\t\t\tstate = INT;\n\t\t\t\t\tnumber = current;\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// parse until next number\n\t\t\t\tif ( state === SEP ) {\n\n\t\t\t\t\t// eat whitespace\n\t\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// start new number\n\t\t\t\t\tif ( RE.DIGIT.test( current ) || RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tstate = INT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double commas (e.g. \"1, , 2\")\n\t\t\t\t\tif ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\t\tif ( seenComma ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tseenComma = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse integer part\n\t\t\t\tif ( state === INT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n\t\t\t\t\tif ( RE.SIGN.test( current )\n\t\t\t\t\t\t\t&& number.length === 1\n\t\t\t\t\t\t\t&& RE.SIGN.test( number[ 0 ] ) ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse decimal part\n\t\t\t\tif ( state === FLOAT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double decimal points (e.g. \"1..2\")\n\t\t\t\t\tif ( RE.POINT.test( current ) && number[ number.length - 1 ] === '.' ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse exponent part\n\t\t\t\tif ( state === EXP ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tif ( exponent === '' ) {\n\n\t\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( exponent.length === 1 && RE.SIGN.test( exponent ) ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\t// end of number\n\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = false;\n\n\t\t\t\t} else if ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = true;\n\n\t\t\t\t} else if ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = INT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else if ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add the last number found (if any)\n\t\t\tnewNumber();\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\t// Units\n\n\t\tconst units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];\n\n\t\t// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\t\tconst unitConversion = {\n\n\t\t\t'mm': {\n\t\t\t\t'mm': 1,\n\t\t\t\t'cm': 0.1,\n\t\t\t\t'in': 1 / 25.4,\n\t\t\t\t'pt': 72 / 25.4,\n\t\t\t\t'pc': 6 / 25.4,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'cm': {\n\t\t\t\t'mm': 10,\n\t\t\t\t'cm': 1,\n\t\t\t\t'in': 1 / 2.54,\n\t\t\t\t'pt': 72 / 2.54,\n\t\t\t\t'pc': 6 / 2.54,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'in': {\n\t\t\t\t'mm': 25.4,\n\t\t\t\t'cm': 2.54,\n\t\t\t\t'in': 1,\n\t\t\t\t'pt': 72,\n\t\t\t\t'pc': 6,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pt': {\n\t\t\t\t'mm': 25.4 / 72,\n\t\t\t\t'cm': 2.54 / 72,\n\t\t\t\t'in': 1 / 72,\n\t\t\t\t'pt': 1,\n\t\t\t\t'pc': 6 / 72,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pc': {\n\t\t\t\t'mm': 25.4 / 6,\n\t\t\t\t'cm': 2.54 / 6,\n\t\t\t\t'in': 1 / 6,\n\t\t\t\t'pt': 72 / 6,\n\t\t\t\t'pc': 1,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'px': {\n\t\t\t\t'px': 1\n\t\t\t}\n\n\t\t};\n\n\t\tfunction parseFloatWithUnits( string ) {\n\n\t\t\tlet theUnit = 'px';\n\n\t\t\tif ( typeof string === 'string' || string instanceof String ) {\n\n\t\t\t\tfor ( let i = 0, n = units.length; i < n; i ++ ) {\n\n\t\t\t\t\tconst u = units[ i ];\n\n\t\t\t\t\tif ( string.endsWith( u ) ) {\n\n\t\t\t\t\t\ttheUnit = u;\n\t\t\t\t\t\tstring = string.substring( 0, string.length - u.length );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet scale = undefined;\n\n\t\t\tif ( theUnit === 'px' && scope.defaultUnit !== 'px' ) {\n\n\t\t\t\t// Conversion scale from  pixels to inches, then to default units\n\n\t\t\t\tscale = unitConversion[ 'in' ][ scope.defaultUnit ] / scope.defaultDPI;\n\n\t\t\t} else {\n\n\t\t\t\tscale = unitConversion[ theUnit ][ scope.defaultUnit ];\n\n\t\t\t\tif ( scale < 0 ) {\n\n\t\t\t\t\t// Conversion scale to pixels\n\n\t\t\t\t\tscale = unitConversion[ theUnit ][ 'in' ] * scope.defaultDPI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn scale * parseFloat( string );\n\n\t\t}\n\n\t\t// Transforms\n\n\t\tfunction getNodeTransform( node ) {\n\n\t\t\tif ( ! ( node.hasAttribute( 'transform' ) || ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) ) ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tconst transform = parseNodeTransform( node );\n\n\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t}\n\n\t\t\tcurrentTransform.copy( transform );\n\t\t\ttransformStack.push( transform );\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction parseNodeTransform( node ) {\n\n\t\t\tconst transform = new Matrix3();\n\t\t\tconst currentTransform = tempTransform0;\n\n\t\t\tif ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) {\n\n\t\t\t\tconst tx = parseFloatWithUnits( node.getAttribute( 'x' ) );\n\t\t\t\tconst ty = parseFloatWithUnits( node.getAttribute( 'y' ) );\n\n\t\t\t\ttransform.translate( tx, ty );\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'transform' ) ) {\n\n\t\t\t\tconst transformsTexts = node.getAttribute( 'transform' ).split( ')' );\n\n\t\t\t\tfor ( let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {\n\n\t\t\t\t\tconst transformText = transformsTexts[ tIndex ].trim();\n\n\t\t\t\t\tif ( transformText === '' ) continue;\n\n\t\t\t\t\tconst openParPos = transformText.indexOf( '(' );\n\t\t\t\t\tconst closeParPos = transformText.length;\n\n\t\t\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\n\n\t\t\t\t\t\tconst transformType = transformText.slice( 0, openParPos );\n\n\t\t\t\t\t\tconst array = parseFloats( transformText.slice( openParPos + 1 ) );\n\n\t\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t\t\tswitch ( transformType ) {\n\n\t\t\t\t\t\t\tcase 'translate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tconst tx = array[ 0 ];\n\t\t\t\t\t\t\t\t\tlet ty = tx;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tty = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.translate( tx, ty );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'rotate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tlet angle = 0;\n\t\t\t\t\t\t\t\t\tlet cx = 0;\n\t\t\t\t\t\t\t\t\tlet cy = 0;\n\n\t\t\t\t\t\t\t\t\t// Angle\n\t\t\t\t\t\t\t\t\tangle = - array[ 0 ] * Math.PI / 180;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 3 ) {\n\n\t\t\t\t\t\t\t\t\t\t// Center x, y\n\t\t\t\t\t\t\t\t\t\tcx = array[ 1 ];\n\t\t\t\t\t\t\t\t\t\tcy = array[ 2 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Rotate around center (cx, cy)\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( - cx, - cy );\n\t\t\t\t\t\t\t\t\ttempTransform2.identity().rotate( angle );\n\t\t\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( cx, cy );\n\t\t\t\t\t\t\t\t\tcurrentTransform.multiplyMatrices( tempTransform1, tempTransform3 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'scale':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tconst scaleX = array[ 0 ];\n\t\t\t\t\t\t\t\t\tlet scaleY = scaleX;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.scale( scaleX, scaleY );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewX':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\n\t\t\t\t\t\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewY':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'matrix':\n\n\t\t\t\t\t\t\t\tif ( array.length === 6 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\n\t\t\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttransform.premultiply( currentTransform );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction transformPath( path, m ) {\n\n\t\t\tfunction transfVec2( v2 ) {\n\n\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\n\n\t\t\t\tv2.set( tempV3.x, tempV3.y );\n\n\t\t\t}\n\n\t\t\tconst isRotated = isTransformRotated( m );\n\n\t\t\tconst subPaths = path.subPaths;\n\n\t\t\tfor ( let i = 0, n = subPaths.length; i < n; i ++ ) {\n\n\t\t\t\tconst subPath = subPaths[ i ];\n\t\t\t\tconst curves = subPath.curves;\n\n\t\t\t\tfor ( let j = 0; j < curves.length; j ++ ) {\n\n\t\t\t\t\tconst curve = curves[ j ];\n\n\t\t\t\t\tif ( curve.isLineCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\t\t\t\t\t\ttransfVec2( curve.v3 );\n\n\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\n\n\t\t\t\t\t\tif ( isRotated ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\n\t\t\t\t\t\ttransfVec2( tempV2 );\n\t\t\t\t\t\tcurve.aX = tempV2.x;\n\t\t\t\t\t\tcurve.aY = tempV2.y;\n\n\t\t\t\t\t\tcurve.xRadius *= getTransformScaleX( m );\n\t\t\t\t\t\tcurve.yRadius *= getTransformScaleY( m );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isTransformRotated( m ) {\n\n\t\t\treturn m.elements[ 1 ] !== 0 || m.elements[ 3 ] !== 0;\n\n\t\t}\n\n\t\tfunction getTransformScaleX( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );\n\n\t\t}\n\n\t\tfunction getTransformScaleY( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );\n\n\t\t}\n\n\t\t//\n\n\t\tconst paths = [];\n\t\tconst stylesheets = {};\n\n\t\tconst transformStack = [];\n\n\t\tconst tempTransform0 = new Matrix3();\n\t\tconst tempTransform1 = new Matrix3();\n\t\tconst tempTransform2 = new Matrix3();\n\t\tconst tempTransform3 = new Matrix3();\n\t\tconst tempV2 = new Vector2();\n\t\tconst tempV3 = new Vector3();\n\n\t\tconst currentTransform = new Matrix3();\n\n\t\tconst xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\n\n\t\tparseNode( xml.documentElement, {\n\t\t\tfill: '#000',\n\t\t\tfillOpacity: 1,\n\t\t\tstrokeOpacity: 1,\n\t\t\tstrokeWidth: 1,\n\t\t\tstrokeLineJoin: 'miter',\n\t\t\tstrokeLineCap: 'butt',\n\t\t\tstrokeMiterLimit: 4\n\t\t} );\n\n\t\tconst data = { paths: paths, xml: xml.documentElement };\n\n\t\t// console.log( paths );\n\t\treturn data;\n\n\t}\n\n\tstatic createShapes( shapePath ) {\n\n\t\t// Param shapePath: a shapepath as returned by the parse function of this class\n\t\t// Returns Shape object\n\n\t\tconst BIGNUMBER = 999999999;\n\n\t\tconst IntersectionLocationType = {\n\t\t\tORIGIN: 0,\n\t\t\tDESTINATION: 1,\n\t\t\tBETWEEN: 2,\n\t\t\tLEFT: 3,\n\t\t\tRIGHT: 4,\n\t\t\tBEHIND: 5,\n\t\t\tBEYOND: 6\n\t\t};\n\n\t\tconst classifyResult = {\n\t\t\tloc: IntersectionLocationType.ORIGIN,\n\t\t\tt: 0\n\t\t};\n\n\t\tfunction findEdgeIntersection( a0, a1, b0, b1 ) {\n\n\t\t\tconst x1 = a0.x;\n\t\t\tconst x2 = a1.x;\n\t\t\tconst x3 = b0.x;\n\t\t\tconst x4 = b1.x;\n\t\t\tconst y1 = a0.y;\n\t\t\tconst y2 = a1.y;\n\t\t\tconst y3 = b0.y;\n\t\t\tconst y4 = b1.y;\n\t\t\tconst nom1 = ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 );\n\t\t\tconst nom2 = ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 );\n\t\t\tconst denom = ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 );\n\t\t\tconst t1 = nom1 / denom;\n\t\t\tconst t2 = nom2 / denom;\n\n\t\t\tif ( ( ( denom === 0 ) && ( nom1 !== 0 ) ) || ( t1 <= 0 ) || ( t1 >= 1 ) || ( t2 < 0 ) || ( t2 > 1 ) ) {\n\n\t\t\t\t//1. lines are parallel or edges don't intersect\n\n\t\t\t\treturn null;\n\n\t\t\t} else if ( ( nom1 === 0 ) && ( denom === 0 ) ) {\n\n\t\t\t\t//2. lines are colinear\n\n\t\t\t\t//check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\n\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\n\t\t\t\t\t//find position of this endpoints relatively to edge1\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\n\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\n\n\t\t\t\t\t} else if ( classifyResult.loc == IntersectionLocationType.BETWEEN ) {\n\n\t\t\t\t\t\tconst x = + ( ( x1 + classifyResult.t * ( x2 - x1 ) ).toPrecision( 10 ) );\n\t\t\t\t\t\tconst y = + ( ( y1 + classifyResult.t * ( y2 - y1 ) ).toPrecision( 10 ) );\n\t\t\t\t\t\treturn { x: x, y: y, t: classifyResult.t, };\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t} else {\n\n\t\t\t\t//3. edges intersect\n\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\n\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\n\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\n\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst x = + ( ( x1 + t1 * ( x2 - x1 ) ).toPrecision( 10 ) );\n\t\t\t\tconst y = + ( ( y1 + t1 * ( y2 - y1 ) ).toPrecision( 10 ) );\n\t\t\t\treturn { x: x, y: y, t: t1 };\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction classifyPoint( p, edgeStart, edgeEnd ) {\n\n\t\t\tconst ax = edgeEnd.x - edgeStart.x;\n\t\t\tconst ay = edgeEnd.y - edgeStart.y;\n\t\t\tconst bx = p.x - edgeStart.x;\n\t\t\tconst by = p.y - edgeStart.y;\n\t\t\tconst sa = ax * by - bx * ay;\n\n\t\t\tif ( ( p.x === edgeStart.x ) && ( p.y === edgeStart.y ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.ORIGIN;\n\t\t\t\tclassifyResult.t = 0;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( ( p.x === edgeEnd.x ) && ( p.y === edgeEnd.y ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.DESTINATION;\n\t\t\t\tclassifyResult.t = 1;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( sa < - Number.EPSILON ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.LEFT;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( sa > Number.EPSILON ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.RIGHT;\n\t\t\t\treturn;\n\n\n\t\t\t}\n\n\t\t\tif ( ( ( ax * bx ) < 0 ) || ( ( ay * by ) < 0 ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEHIND;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( ( Math.sqrt( ax * ax + ay * ay ) ) < ( Math.sqrt( bx * bx + by * by ) ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEYOND;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tlet t;\n\n\t\t\tif ( ax !== 0 ) {\n\n\t\t\t\tt = bx / ax;\n\n\t\t\t} else {\n\n\t\t\t\tt = by / ay;\n\n\t\t\t}\n\n\t\t\tclassifyResult.loc = IntersectionLocationType.BETWEEN;\n\t\t\tclassifyResult.t = t;\n\n\t\t}\n\n\t\tfunction getIntersections( path1, path2 ) {\n\n\t\t\tconst intersectionsRaw = [];\n\t\t\tconst intersections = [];\n\n\t\t\tfor ( let index = 1; index < path1.length; index ++ ) {\n\n\t\t\t\tconst path1EdgeStart = path1[ index - 1 ];\n\t\t\t\tconst path1EdgeEnd = path1[ index ];\n\n\t\t\t\tfor ( let index2 = 1; index2 < path2.length; index2 ++ ) {\n\n\t\t\t\t\tconst path2EdgeStart = path2[ index2 - 1 ];\n\t\t\t\t\tconst path2EdgeEnd = path2[ index2 ];\n\n\t\t\t\t\tconst intersection = findEdgeIntersection( path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd );\n\n\t\t\t\t\tif ( intersection !== null && intersectionsRaw.find( i => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON ) === undefined ) {\n\n\t\t\t\t\t\tintersectionsRaw.push( intersection );\n\t\t\t\t\t\tintersections.push( new Vector2( intersection.x, intersection.y ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn intersections;\n\n\t\t}\n\n\t\tfunction getScanlineIntersections( scanline, boundingBox, paths ) {\n\n\t\t\tconst center = new Vector2();\n\t\t\tboundingBox.getCenter( center );\n\n\t\t\tconst allIntersections = [];\n\n\t\t\tpaths.forEach( path => {\n\n\t\t\t\t// check if the center of the bounding box is in the bounding box of the paths.\n\t\t\t\t// this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n\t\t\t\t// if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\n\t\t\t\tif ( path.boundingBox.containsPoint( center ) ) {\n\n\t\t\t\t\tconst intersections = getIntersections( scanline, path.points );\n\n\t\t\t\t\tintersections.forEach( p => {\n\n\t\t\t\t\t\tallIntersections.push( { identifier: path.identifier, isCW: path.isCW, point: p } );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tallIntersections.sort( ( i1, i2 ) => {\n\n\t\t\t\treturn i1.point.x - i2.point.x;\n\n\t\t\t} );\n\n\t\t\treturn allIntersections;\n\n\t\t}\n\n\t\tfunction isHoleTo( simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule ) {\n\n\t\t\tif ( _fillRule === null || _fillRule === undefined || _fillRule === '' ) {\n\n\t\t\t\t_fillRule = 'nonzero';\n\n\t\t\t}\n\n\t\t\tconst centerBoundingBox = new Vector2();\n\t\t\tsimplePath.boundingBox.getCenter( centerBoundingBox );\n\n\t\t\tconst scanline = [ new Vector2( scanlineMinX, centerBoundingBox.y ), new Vector2( scanlineMaxX, centerBoundingBox.y ) ];\n\n\t\t\tconst scanlineIntersections = getScanlineIntersections( scanline, simplePath.boundingBox, allPaths );\n\n\t\t\tscanlineIntersections.sort( ( i1, i2 ) => {\n\n\t\t\t\treturn i1.point.x - i2.point.x;\n\n\t\t\t} );\n\n\t\t\tconst baseIntersections = [];\n\t\t\tconst otherIntersections = [];\n\n\t\t\tscanlineIntersections.forEach( i => {\n\n\t\t\t\tif ( i.identifier === simplePath.identifier ) {\n\n\t\t\t\t\tbaseIntersections.push( i );\n\n\t\t\t\t} else {\n\n\t\t\t\t\totherIntersections.push( i );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tconst firstXOfPath = baseIntersections[ 0 ].point.x;\n\n\t\t\t// build up the path hierarchy\n\t\t\tconst stack = [];\n\t\t\tlet i = 0;\n\n\t\t\twhile ( i < otherIntersections.length && otherIntersections[ i ].point.x < firstXOfPath ) {\n\n\t\t\t\tif ( stack.length > 0 && stack[ stack.length - 1 ] === otherIntersections[ i ].identifier ) {\n\n\t\t\t\t\tstack.pop();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstack.push( otherIntersections[ i ].identifier );\n\n\t\t\t\t}\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\tstack.push( simplePath.identifier );\n\n\t\t\tif ( _fillRule === 'evenodd' ) {\n\n\t\t\t\tconst isHole = stack.length % 2 === 0 ? true : false;\n\t\t\t\tconst isHoleFor = stack[ stack.length - 2 ];\n\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\n\n\t\t\t} else if ( _fillRule === 'nonzero' ) {\n\n\t\t\t\t// check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n\t\t\t\tlet isHole = true;\n\t\t\t\tlet isHoleFor = null;\n\t\t\t\tlet lastCWValue = null;\n\n\t\t\t\tfor ( let i = 0; i < stack.length; i ++ ) {\n\n\t\t\t\t\tconst identifier = stack[ i ];\n\t\t\t\t\tif ( isHole ) {\n\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\n\t\t\t\t\t\tisHole = false;\n\t\t\t\t\t\tisHoleFor = identifier;\n\n\t\t\t\t\t} else if ( lastCWValue !== allPaths[ identifier ].isCW ) {\n\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\n\t\t\t\t\t\tisHole = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'fill-rule: \"' + _fillRule + '\" is currently not implemented.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check for self intersecting paths\n\t\t// TODO\n\n\t\t// check intersecting paths\n\t\t// TODO\n\n\t\t// prepare paths for hole detection\n\t\tlet identifier = 0;\n\n\t\tlet scanlineMinX = BIGNUMBER;\n\t\tlet scanlineMaxX = - BIGNUMBER;\n\n\t\tlet simplePaths = shapePath.subPaths.map( p => {\n\n\t\t\tconst points = p.getPoints();\n\t\t\tlet maxY = - BIGNUMBER;\n\t\t\tlet minY = BIGNUMBER;\n\t\t\tlet maxX = - BIGNUMBER;\n\t\t\tlet minX = BIGNUMBER;\n\n\t      \t//points.forEach(p => p.y *= -1);\n\n\t\t\tfor ( let i = 0; i < points.length; i ++ ) {\n\n\t\t\t\tconst p = points[ i ];\n\n\t\t\t\tif ( p.y > maxY ) {\n\n\t\t\t\t\tmaxY = p.y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.y < minY ) {\n\n\t\t\t\t\tminY = p.y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.x > maxX ) {\n\n\t\t\t\t\tmaxX = p.x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.x < minX ) {\n\n\t\t\t\t\tminX = p.x;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\t\t\tif ( scanlineMaxX <= maxX ) {\n\n\t\t\t\tscanlineMaxX = maxX + 1;\n\n\t\t\t}\n\n\t\t\tif ( scanlineMinX >= minX ) {\n\n\t\t\t\tscanlineMinX = minX - 1;\n\n\t\t\t}\n\n\t\t\treturn { curves: p.curves, points: points, isCW: ShapeUtils.isClockWise( points ), identifier: identifier ++, boundingBox: new Box2( new Vector2( minX, minY ), new Vector2( maxX, maxY ) ) };\n\n\t\t} );\n\n\t\tsimplePaths = simplePaths.filter( sp => sp.points.length > 1 );\n\n\t\t// check if path is solid or a hole\n\t\tconst isAHole = simplePaths.map( p => isHoleTo( p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData.style.fillRule ) );\n\n\n\t\tconst shapesToReturn = [];\n\t\tsimplePaths.forEach( p => {\n\n\t\t\tconst amIAHole = isAHole[ p.identifier ];\n\n\t\t\tif ( ! amIAHole.isHole ) {\n\n\t\t\t\tconst shape = new Shape();\n\t\t\t\tshape.curves = p.curves;\n\t\t\t\tconst holes = isAHole.filter( h => h.isHole && h.for === p.identifier );\n\t\t\t\tholes.forEach( h => {\n\n\t\t\t\t\tconst hole = simplePaths[ h.identifier ];\n\t\t\t\t\tconst path = new Path();\n\t\t\t\t\tpath.curves = hole.curves;\n\t\t\t\t\tshape.holes.push( path );\n\n\t\t\t\t} );\n\t\t\t\tshapesToReturn.push( shape );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn shapesToReturn;\n\n\t}\n\n\tstatic getStrokeStyle( width, color, lineJoin, lineCap, miterLimit ) {\n\n\t\t// Param width: Stroke width\n\t\t// Param color: As returned by THREE.Color.getStyle()\n\t\t// Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n\t\t// Param lineCap: One of \"round\", \"square\" or \"butt\"\n\t\t// Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n\t\t// Returns style object\n\n\t\twidth = width !== undefined ? width : 1;\n\t\tcolor = color !== undefined ? color : '#000';\n\t\tlineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n\t\tlineCap = lineCap !== undefined ? lineCap : 'butt';\n\t\tmiterLimit = miterLimit !== undefined ? miterLimit : 4;\n\n\t\treturn {\n\t\t\tstrokeColor: color,\n\t\t\tstrokeWidth: width,\n\t\t\tstrokeLineJoin: lineJoin,\n\t\t\tstrokeLineCap: lineCap,\n\t\t\tstrokeMiterLimit: miterLimit\n\t\t};\n\n\t}\n\n\tstatic pointsToStroke( points, style, arcDivisions, minDistance ) {\n\n\t\t// Generates a stroke with some witdh around the given path.\n\t\t// The path can be open or closed (last point equals to first point)\n\t\t// Param points: Array of Vector2D (the path). Minimum 2 points.\n\t\t// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n\t\t// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n\t\t// Param minDistance: Points closer to this distance will be merged. (Optional)\n\t\t// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\tif ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\treturn geometry;\n\n\t}\n\n\tstatic pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {\n\n\t\t// This function can be called to update existing arrays or buffers.\n\t\t// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n\t\t// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n\t\t// Returns number of written vertices / normals / uvs pairs\n\t\t// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n\t\t// 'normals' and 'uvs' buffers are optional\n\n\t\tconst tempV2_1 = new Vector2();\n\t\tconst tempV2_2 = new Vector2();\n\t\tconst tempV2_3 = new Vector2();\n\t\tconst tempV2_4 = new Vector2();\n\t\tconst tempV2_5 = new Vector2();\n\t\tconst tempV2_6 = new Vector2();\n\t\tconst tempV2_7 = new Vector2();\n\t\tconst lastPointL = new Vector2();\n\t\tconst lastPointR = new Vector2();\n\t\tconst point0L = new Vector2();\n\t\tconst point0R = new Vector2();\n\t\tconst currentPointL = new Vector2();\n\t\tconst currentPointR = new Vector2();\n\t\tconst nextPointL = new Vector2();\n\t\tconst nextPointR = new Vector2();\n\t\tconst innerPoint = new Vector2();\n\t\tconst outerPoint = new Vector2();\n\n\t\tarcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n\t\tminDistance = minDistance !== undefined ? minDistance : 0.001;\n\t\tvertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\n\n\t\t// First ensure there are no duplicated points\n\t\tpoints = removeDuplicatedPoints( points );\n\n\t\tconst numPoints = points.length;\n\n\t\tif ( numPoints < 2 ) return 0;\n\n\t\tconst isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );\n\n\t\tlet currentPoint;\n\t\tlet previousPoint = points[ 0 ];\n\t\tlet nextPoint;\n\n\t\tconst strokeWidth2 = style.strokeWidth / 2;\n\n\t\tconst deltaU = 1 / ( numPoints - 1 );\n\t\tlet u0 = 0, u1;\n\n\t\tlet innerSideModified;\n\t\tlet joinIsOnLeftSide;\n\t\tlet isMiter;\n\t\tlet initialJoinIsOnLeftSide = false;\n\n\t\tlet numVertices = 0;\n\t\tlet currentCoordinate = vertexOffset * 3;\n\t\tlet currentCoordinateUV = vertexOffset * 2;\n\n\t\t// Get initial left and right stroke points\n\t\tgetNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );\n\t\tlastPointL.copy( points[ 0 ] ).sub( tempV2_1 );\n\t\tlastPointR.copy( points[ 0 ] ).add( tempV2_1 );\n\t\tpoint0L.copy( lastPointL );\n\t\tpoint0R.copy( lastPointR );\n\n\t\tfor ( let iPoint = 1; iPoint < numPoints; iPoint ++ ) {\n\n\t\t\tcurrentPoint = points[ iPoint ];\n\n\t\t\t// Get next point\n\t\t\tif ( iPoint === numPoints - 1 ) {\n\n\t\t\t\tif ( isClosed ) {\n\n\t\t\t\t\t// Skip duplicated initial point\n\t\t\t\t\tnextPoint = points[ 1 ];\n\n\t\t\t\t} else nextPoint = undefined;\n\n\t\t\t} else {\n\n\t\t\t\tnextPoint = points[ iPoint + 1 ];\n\n\t\t\t}\n\n\t\t\t// Normal of previous segment in tempV2_1\n\t\t\tconst normal1 = tempV2_1;\n\t\t\tgetNormal( previousPoint, currentPoint, normal1 );\n\n\t\t\ttempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );\n\t\t\tcurrentPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\tcurrentPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\tu1 = u0 + deltaU;\n\n\t\t\tinnerSideModified = false;\n\n\t\t\tif ( nextPoint !== undefined ) {\n\n\t\t\t\t// Normal of next segment in tempV2_2\n\t\t\t\tgetNormal( currentPoint, nextPoint, tempV2_2 );\n\n\t\t\t\ttempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );\n\t\t\t\tnextPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\t\tnextPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\t\tjoinIsOnLeftSide = true;\n\t\t\t\ttempV2_3.subVectors( nextPoint, previousPoint );\n\t\t\t\tif ( normal1.dot( tempV2_3 ) < 0 ) {\n\n\t\t\t\t\tjoinIsOnLeftSide = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n\n\t\t\t\ttempV2_3.subVectors( nextPoint, currentPoint );\n\t\t\t\ttempV2_3.normalize();\n\t\t\t\tconst dot = Math.abs( normal1.dot( tempV2_3 ) );\n\n\t\t\t\t// If path is straight, don't create join\n\t\t\t\tif ( dot !== 0 ) {\n\n\t\t\t\t\t// Compute inner and outer segment intersections\n\t\t\t\t\tconst miterSide = strokeWidth2 / dot;\n\t\t\t\t\ttempV2_3.multiplyScalar( - miterSide );\n\t\t\t\t\ttempV2_4.subVectors( currentPoint, previousPoint );\n\t\t\t\t\ttempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );\n\t\t\t\t\tinnerPoint.copy( tempV2_5 ).negate();\n\t\t\t\t\tconst miterLength2 = tempV2_5.length();\n\t\t\t\t\tconst segmentLengthPrev = tempV2_4.length();\n\t\t\t\t\ttempV2_4.divideScalar( segmentLengthPrev );\n\t\t\t\t\ttempV2_6.subVectors( nextPoint, currentPoint );\n\t\t\t\t\tconst segmentLengthNext = tempV2_6.length();\n\t\t\t\t\ttempV2_6.divideScalar( segmentLengthNext );\n\t\t\t\t\t// Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\t\t\t\t\tif ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {\n\n\t\t\t\t\t\tinnerSideModified = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\touterPoint.copy( tempV2_5 ).add( currentPoint );\n\t\t\t\t\tinnerPoint.add( currentPoint );\n\n\t\t\t\t\tisMiter = false;\n\n\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\tnextPointR.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointR.copy( innerPoint );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tnextPointL.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointL.copy( innerPoint );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// The segment triangles are generated here if there was overlapping\n\n\t\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( style.strokeLineJoin ) {\n\n\t\t\t\t\t\tcase 'bevel':\n\n\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'round':\n\n\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t// Join triangles\n\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'miter':\n\t\t\t\t\t\tcase 'miter-clip':\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tconst miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;\n\n\t\t\t\t\t\t\tif ( miterFraction < 1 ) {\n\n\t\t\t\t\t\t\t\t// The join miter length exceeds the miter limit\n\n\t\t\t\t\t\t\t\tif ( style.strokeLineJoin !== 'miter-clip' ) {\n\n\t\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t\t\t// Miter-clip join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Miter join segment triangles\n\n\t\t\t\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\t\t\t\t// Optimized segment + join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\tnextPointL.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tnextPointR.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Add extra miter join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tisMiter = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// The segment triangles are generated here when two consecutive points are collinear\n\n\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// The segment triangles are generated here if it is the ending segment\n\n\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t}\n\n\t\t\tif ( ! isClosed && iPoint === numPoints - 1 ) {\n\n\t\t\t\t// Start line endcap\n\t\t\t\taddCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );\n\n\t\t\t}\n\n\t\t\t// Increment loop variables\n\n\t\t\tu0 = u1;\n\n\t\t\tpreviousPoint = currentPoint;\n\n\t\t\tlastPointL.copy( nextPointL );\n\t\t\tlastPointR.copy( nextPointR );\n\n\t\t}\n\n\t\tif ( ! isClosed ) {\n\n\t\t\t// Ending line endcap\n\t\t\taddCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );\n\n\t\t} else if ( innerSideModified && vertices ) {\n\n\t\t\t// Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n\t\t\tlet lastOuter = outerPoint;\n\t\t\tlet lastInner = innerPoint;\n\n\t\t\tif ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {\n\n\t\t\t\tlastOuter = innerPoint;\n\t\t\t\tlastInner = outerPoint;\n\n\t\t\t}\n\n\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\tif ( isMiter || initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 0 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 1 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( isMiter || ! initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 1 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn numVertices;\n\n\t\t// -- End of algorithm\n\n\t\t// -- Functions\n\n\t\tfunction getNormal( p1, p2, result ) {\n\n\t\t\tresult.subVectors( p2, p1 );\n\t\t\treturn result.set( - result.y, result.x ).normalize();\n\n\t\t}\n\n\t\tfunction addVertex( position, u, v ) {\n\n\t\t\tif ( vertices ) {\n\n\t\t\t\tvertices[ currentCoordinate ] = position.x;\n\t\t\t\tvertices[ currentCoordinate + 1 ] = position.y;\n\t\t\t\tvertices[ currentCoordinate + 2 ] = 0;\n\n\t\t\t\tif ( normals ) {\n\n\t\t\t\t\tnormals[ currentCoordinate ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 1 ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 2 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t\tcurrentCoordinate += 3;\n\n\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\tuvs[ currentCoordinateUV ] = u;\n\t\t\t\t\tuvs[ currentCoordinateUV + 1 ] = v;\n\n\t\t\t\t\tcurrentCoordinateUV += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnumVertices += 3;\n\n\t\t}\n\n\t\tfunction makeCircularSector( center, p1, p2, u, v ) {\n\n\t\t\t// param p1, p2: Points in the circle arc.\n\t\t\t// p1 and p2 are in clockwise direction.\n\n\t\t\ttempV2_1.copy( p1 ).sub( center ).normalize();\n\t\t\ttempV2_2.copy( p2 ).sub( center ).normalize();\n\n\t\t\tlet angle = Math.PI;\n\t\t\tconst dot = tempV2_1.dot( tempV2_2 );\n\t\t\tif ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );\n\n\t\t\tangle /= arcDivisions;\n\n\t\t\ttempV2_3.copy( p1 );\n\n\t\t\tfor ( let i = 0, il = arcDivisions - 1; i < il; i ++ ) {\n\n\t\t\t\ttempV2_4.copy( tempV2_3 ).rotateAround( center, angle );\n\n\t\t\t\taddVertex( tempV2_3, u, v );\n\t\t\t\taddVertex( tempV2_4, u, v );\n\t\t\t\taddVertex( center, u, 0.5 );\n\n\t\t\t\ttempV2_3.copy( tempV2_4 );\n\n\t\t\t}\n\n\t\t\taddVertex( tempV2_4, u, v );\n\t\t\taddVertex( p2, u, v );\n\t\t\taddVertex( center, u, 0.5 );\n\n\t\t}\n\n\t\tfunction makeSegmentTriangles() {\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( currentPointL, u1, 1 );\n\t\t\taddVertex( currentPointR, u1, 0 );\n\n\t\t}\n\n\t\tfunction makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t// Optimized segment + bevel triangles\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bevel join triangle. The segment triangles are done in the main loop\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( nextPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointR, u0, 1 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( nextPointR, u0, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {\n\n\t\t\t// param center: End point of the path\n\t\t\t// param p1, p2: Left and right cap points\n\n\t\t\tswitch ( style.strokeLineCap ) {\n\n\t\t\t\tcase 'round':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\tmakeCircularSector( center, p2, p1, u, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmakeCircularSector( center, p1, p2, u, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'square':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p1, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 3 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p2, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\tconst vl = vertices.length;\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'butt':\n\t\t\t\tdefault:\n\n\t\t\t\t\t// Nothing to do here\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction removeDuplicatedPoints( points ) {\n\n\t\t\t// Creates a new array if necessary with duplicated points removed.\n\t\t\t// This does not remove duplicated initial and ending points of a closed path.\n\n\t\t\tlet dupPoints = false;\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {\n\n\t\t\t\t\tdupPoints = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! dupPoints ) return points;\n\n\t\t\tconst newPoints = [];\n\t\t\tnewPoints.push( points[ 0 ] );\n\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {\n\n\t\t\t\t\tnewPoints.push( points[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewPoints.push( points[ points.length - 1 ] );\n\n\t\t\treturn newPoints;\n\n\t\t}\n\n\t}\n\n\n}\n\nexport { SVGLoader };\n"],"names":["MapControls","React","props","enableDamping","ref","domElement","camera","onChange","onStart","onEnd","rest","invalidate","useThree","state","defaultCamera","gl","events","explDomElement","connected","explCamera","controls","MapControls$1","connect","callback","e","addEventListener","dispose","removeEventListener","useFrame","update","_extends","object","SVGLoader","manager","defaultDPI","defaultUnit","url","onLoad","onProgress","onError","scope","this","loader","FileLoader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","load","text","parse","console","error","itemError","parseArcCommand","rx","ry","x_axis_rotation","large_arc_flag","sweep_flag","start","end","Math","PI","abs","dx2","x","dy2","y","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","s","sqrt","dq","pq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","currentPath","absellipse","lineTo","ux","uy","vx","vy","dot","len","ang","acos","min","parseStyle","node","style","Object","assign","stylesheetStyles","hasAttribute","classSelectors","getAttribute","split","filter","Boolean","map","i","trim","length","stylesheets","addStyle","svgName","jsName","adjustFunction","undefined","v","startsWith","warn","clamp","parseFloatWithUnits","positive","getReflection","a","b","parseFloats","input","flags","stride","TypeError","current","RE","SEPARATOR","WHITESPACE","DIGIT","SIGN","POINT","COMMA","EXP","FLAGS","seenComma","number","exponent","result","throwSyntaxError","partial","SyntaxError","newNumber","push","Number","pow","Array","isArray","includes","test","units","unitConversion","string","theUnit","String","n","u","endsWith","substring","scale","parseFloat","getTransformScaleX","m","te","elements","getTransformScaleY","paths","transformStack","tempTransform0","Matrix3","tempTransform1","tempTransform2","tempTransform3","tempV2","Vector2","tempV3","Vector3","currentTransform","xml","DOMParser","parseFromString","parseNode","nodeType","transform","nodeName","tx","ty","translate","transformsTexts","tIndex","transformText","openParPos","indexOf","closeParPos","transformType","slice","array","identity","angle","rotate","multiplyMatrices","scaleX","scaleY","set","tan","premultiply","parseNodeTransform","copy","getNodeTransform","isDefsNode","sheet","cssRules","stylesheet","type","selectorList","selectorText","j","definitions","fromEntries","entries","parseCSSStylesheet","ShapePath","point","control","firstPoint","isFirstPoint","doSetFirstPoint","commands","match","l","command","charAt","data","numbers","jl","moveTo","bezierCurveTo","quadraticCurveTo","clone","autoClose","curves","currentPoint","parsePathNode","w","h","bci","parseRectNode","iterator","index","regex","replace","parsePolygonNode","parsePolylineNode","r","subpath","Path","absarc","subPaths","parseCircleNode","parseEllipseNode","x1","y1","x2","y2","parseLineNode","usedNodeId","getAttributeNS","usedNode","viewportElement","getElementById","fill","color","setStyle","transfVec2","v2","applyMatrix3","isRotated","isTransformRotated","curve","isLineCurve","v1","isCubicBezierCurve","v0","v3","isQuadraticBezierCurve","isEllipseCurve","aX","aY","xRadius","yRadius","transformPath","userData","childNodes","pop","documentElement","fillOpacity","strokeOpacity","strokeWidth","strokeLineJoin","strokeLineCap","strokeMiterLimit","shapePath","BIGNUMBER","IntersectionLocationType","classifyResult","loc","t","findEdgeIntersection","a0","a1","b0","b1","x3","x4","y3","y4","nom1","denom","t1","t2","classifyPoint","toPrecision","p","edgeStart","edgeEnd","ax","ay","bx","by","sa","EPSILON","getScanlineIntersections","scanline","boundingBox","center","getCenter","allIntersections","forEach","containsPoint","path1","path2","intersectionsRaw","intersections","path1EdgeStart","path1EdgeEnd","index2","path2EdgeStart","path2EdgeEnd","intersection","find","getIntersections","points","identifier","isCW","sort","i1","i2","scanlineMinX","scanlineMaxX","simplePaths","getPoints","maxY","minY","maxX","minX","ShapeUtils","Box2","isAHole","sp","simplePath","allPaths","_fillRule","centerBoundingBox","scanlineIntersections","baseIntersections","otherIntersections","firstXOfPath","stack","isHole","isHoleFor","for","lastCWValue","isHoleTo","fillRule","shapesToReturn","shape","Shape","hole","holes","width","lineJoin","lineCap","miterLimit","strokeColor","arcDivisions","minDistance","vertices","normals","uvs","pointsToStrokeWithBuffers","geometry","BufferGeometry","setAttribute","Float32BufferAttribute","vertexOffset","tempV2_1","tempV2_2","tempV2_3","tempV2_4","tempV2_5","tempV2_6","tempV2_7","lastPointL","lastPointR","point0L","point0R","currentPointL","currentPointR","nextPointL","nextPointR","innerPoint","outerPoint","numPoints","dupPoints","distanceTo","newPoints","removeDuplicatedPoints","nextPoint","u1","innerSideModified","joinIsOnLeftSide","isMiter","isClosed","equals","previousPoint","strokeWidth2","deltaU","u0","initialJoinIsOnLeftSide","numVertices","currentCoordinate","currentCoordinateUV","getNormal","multiplyScalar","sub","add","iPoint","normal1","subVectors","normalize","miterSide","setLength","negate","miterLength2","segmentLengthPrev","divideScalar","segmentLengthNext","makeSegmentTriangles","makeSegmentWithBevelJoin","createSegmentTrianglesWithMiddleSection","makeCircularSector","miterFraction","addVertex","addCapGeometry","lastOuter","lastInner","toArray","p1","p2","position","il","rotateAround","addVectors","vl","Loader"],"sourceRoot":""}