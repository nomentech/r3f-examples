{"version":3,"file":"static/js/81.34abafa3.chunk.js","mappings":"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","sources":["../node_modules/three-stdlib/shaders/HorizontalBlurShader.js","../node_modules/three-stdlib/shaders/VerticalBlurShader.js","../node_modules/@react-three/drei/core/ContactShadows.js","../node_modules/three-stdlib/loaders/RGBELoader.js","../node_modules/@react-three/drei/helpers/environment-assets.js","../node_modules/@react-three/drei/core/shapes.js","../node_modules/@react-three/drei/core/Environment.js","../node_modules/@react-three/drei/helpers/glsl/GroundProjection.frag.glsl.js","../node_modules/@react-three/drei/helpers/glsl/GroundProjection.vert.glsl.js","../node_modules/@react-three/drei/core/Stage.js"],"sourcesContent":["/**\n * Two pass Gaussian blur filter (horizontal and vertical blur shaders)\n * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/\n *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n */\nconst HorizontalBlurShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    h: {\n      value: 1.0 / 512.0\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n      varying vec2 vUv;\n\n      void main() {\n\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n      }\n  `,\n  fragmentShader:\n  /* glsl */\n  `\n    uniform sampler2D tDiffuse;\n    uniform float h;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 sum = vec4( 0.0 );\n\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n    \tgl_FragColor = sum;\n\n    }\n  `\n};\n\nexport { HorizontalBlurShader };\n","/**\n * Two pass Gaussian blur filter (horizontal and vertical blur shaders)\n * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/\n *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n */\nconst VerticalBlurShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    v: {\n      value: 1.0 / 512.0\n    }\n  },\n  vertexShader:\n  /* glsl */\n  `\n    varying vec2 vUv;\n\n    void main() {\n\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n  fragmentShader:\n  /* glsl */\n  `\n\n  uniform sampler2D tDiffuse;\n  uniform float v;\n\n  varying vec2 vUv;\n\n  void main() {\n\n    vec4 sum = vec4( 0.0 );\n\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\n\n    gl_FragColor = sum;\n\n  }\n  `\n};\n\nexport { VerticalBlurShader };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport { HorizontalBlurShader, VerticalBlurShader } from 'three-stdlib';\n\nconst ContactShadows = /*#__PURE__*/React.forwardRef(({\n  scale = 10,\n  frames = Infinity,\n  opacity = 1,\n  width = 1,\n  height = 1,\n  blur = 1,\n  far = 10,\n  resolution = 512,\n  smooth = true,\n  color = '#000000',\n  depthWrite = false,\n  renderOrder,\n  ...props\n}, ref) => {\n  const scene = useThree(state => state.scene);\n  const gl = useThree(state => state.gl);\n  const shadowCamera = React.useRef(null);\n  width = width * (Array.isArray(scale) ? scale[0] : scale || 1);\n  height = height * (Array.isArray(scale) ? scale[1] : scale || 1);\n  const [renderTarget, planeGeometry, depthMaterial, blurPlane, horizontalBlurMaterial, verticalBlurMaterial, renderTargetBlur] = React.useMemo(() => {\n    const renderTarget = new THREE.WebGLRenderTarget(resolution, resolution);\n    const renderTargetBlur = new THREE.WebGLRenderTarget(resolution, resolution);\n    renderTargetBlur.texture.generateMipmaps = renderTarget.texture.generateMipmaps = false;\n    const planeGeometry = new THREE.PlaneBufferGeometry(width, height).rotateX(Math.PI / 2);\n    const blurPlane = new THREE.Mesh(planeGeometry);\n    const depthMaterial = new THREE.MeshDepthMaterial();\n    depthMaterial.depthTest = depthMaterial.depthWrite = false;\n\n    depthMaterial.onBeforeCompile = shader => {\n      shader.uniforms = { ...shader.uniforms,\n        ucolor: {\n          value: new THREE.Color(color).convertSRGBToLinear()\n        }\n      };\n      shader.fragmentShader = shader.fragmentShader.replace(`void main() {`, //\n      `uniform vec3 ucolor;\n           void main() {\n          `);\n      shader.fragmentShader = shader.fragmentShader.replace('vec4( vec3( 1.0 - fragCoordZ ), opacity );', 'vec4( ucolor, ( 1.0 - fragCoordZ ) * 1.0 );');\n    };\n\n    const horizontalBlurMaterial = new THREE.ShaderMaterial(HorizontalBlurShader);\n    const verticalBlurMaterial = new THREE.ShaderMaterial(VerticalBlurShader);\n    verticalBlurMaterial.depthTest = horizontalBlurMaterial.depthTest = false;\n    return [renderTarget, planeGeometry, depthMaterial, blurPlane, horizontalBlurMaterial, verticalBlurMaterial, renderTargetBlur];\n  }, [resolution, width, height, scale, color]);\n\n  const blurShadows = blur => {\n    blurPlane.visible = true;\n    blurPlane.material = horizontalBlurMaterial;\n    horizontalBlurMaterial.uniforms.tDiffuse.value = renderTarget.texture;\n    horizontalBlurMaterial.uniforms.h.value = blur * 1 / 256;\n    gl.setRenderTarget(renderTargetBlur);\n    gl.render(blurPlane, shadowCamera.current);\n    blurPlane.material = verticalBlurMaterial;\n    verticalBlurMaterial.uniforms.tDiffuse.value = renderTargetBlur.texture;\n    verticalBlurMaterial.uniforms.v.value = blur * 1 / 256;\n    gl.setRenderTarget(renderTarget);\n    gl.render(blurPlane, shadowCamera.current);\n    blurPlane.visible = false;\n  };\n\n  let count = 0;\n  useFrame(() => {\n    if (shadowCamera.current && (frames === Infinity || count < frames)) {\n      const initialBackground = scene.background;\n      scene.background = null;\n      const initialOverrideMaterial = scene.overrideMaterial;\n      scene.overrideMaterial = depthMaterial;\n      gl.setRenderTarget(renderTarget);\n      gl.render(scene, shadowCamera.current);\n      scene.overrideMaterial = initialOverrideMaterial;\n      blurShadows(blur);\n      if (smooth) blurShadows(blur * 0.4);\n      gl.setRenderTarget(null);\n      scene.background = initialBackground;\n      count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    \"rotation-x\": Math.PI / 2\n  }, props, {\n    ref: ref\n  }), /*#__PURE__*/React.createElement(\"mesh\", {\n    renderOrder: renderOrder,\n    geometry: planeGeometry,\n    scale: [1, -1, 1],\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    map: renderTarget.texture,\n    \"map-encoding\": gl.outputEncoding,\n    transparent: true,\n    opacity: opacity,\n    depthWrite: depthWrite\n  })), /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    ref: shadowCamera,\n    args: [-width / 2, width / 2, height / 2, -height / 2, 0, far]\n  }));\n});\n\nexport { ContactShadows };\n","import { DataTextureLoader, HalfFloatType, FloatType, DataUtils, LinearEncoding, LinearFilter } from 'three';\n\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nclass RGBELoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = HalfFloatType;\n  } // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n\n  parse(buffer) {\n    const\n    /* return codes for rgbe routines */\n    //RGBE_RETURN_SUCCESS = 0,\n    RGBE_RETURN_FAILURE = -1,\n\n    /* default error routine.  change this to change error handling */\n    rgbe_read_error = 1,\n          rgbe_write_error = 2,\n          rgbe_format_error = 3,\n          rgbe_memory_error = 4,\n          rgbe_error = function (rgbe_error_code, msg) {\n      switch (rgbe_error_code) {\n        case rgbe_read_error:\n          console.error('THREE.RGBELoader Read Error: ' + (msg || ''));\n          break;\n\n        case rgbe_write_error:\n          console.error('THREE.RGBELoader Write Error: ' + (msg || ''));\n          break;\n\n        case rgbe_format_error:\n          console.error('THREE.RGBELoader Bad File Format: ' + (msg || ''));\n          break;\n\n        default:\n        case rgbe_memory_error:\n          console.error('THREE.RGBELoader: Error: ' + (msg || ''));\n      }\n\n      return RGBE_RETURN_FAILURE;\n    },\n\n    /* offsets to red, green, and blue components in a data (float) pixel */\n    //RGBE_DATA_RED = 0,\n    //RGBE_DATA_GREEN = 1,\n    //RGBE_DATA_BLUE = 2,\n\n    /* number of floats per pixel, use 4 since stored in rgba image format */\n    //RGBE_DATA_SIZE = 4,\n\n    /* flags indicating which fields in an rgbe_header_info are valid */\n    RGBE_VALID_PROGRAMTYPE = 1,\n          RGBE_VALID_FORMAT = 2,\n          RGBE_VALID_DIMENSIONS = 4,\n          NEWLINE = '\\n',\n          fgets = function (buffer, lineLimit, consume) {\n      const chunkSize = 128;\n      lineLimit = !lineLimit ? 1024 : lineLimit;\n      let p = buffer.pos,\n          i = -1,\n          len = 0,\n          s = '',\n          chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n\n      while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\n        s += chunk;\n        len += chunk.length;\n        p += chunkSize;\n        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n      }\n\n      if (-1 < i) {\n        /*for (i=l-1; i>=0; i--) {\n        byteCode = m.charCodeAt(i);\n        if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n        else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n        if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n        }*/\n        if (false !== consume) buffer.pos += len + i + 1;\n        return s + chunk.slice(0, i);\n      }\n\n      return false;\n    },\n\n    /* minimal header reading.  modify if you want to parse more information */\n    RGBE_ReadHeader = function (buffer) {\n      // regexes to parse header info fields\n      const magic_token_re = /^#\\?(\\S+)/,\n            gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n            exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n            format_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n            dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n            // RGBE format header struct\n      header = {\n        valid: 0\n        /* indicate which fields are valid */\n        ,\n        string: ''\n        /* the actual header string */\n        ,\n        comments: ''\n        /* comments found in header */\n        ,\n        programtype: 'RGBE'\n        /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n        ,\n        format: ''\n        /* RGBE format, default 32-bit_rle_rgbe */\n        ,\n        gamma: 1.0\n        /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n        ,\n        exposure: 1.0\n        /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n        ,\n        width: 0,\n        height: 0\n        /* image dimensions, width/height */\n\n      };\n      let line, match;\n\n      if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\n        return rgbe_error(rgbe_read_error, 'no header found');\n      }\n      /* if you want to require the magic token then uncomment the next line */\n\n\n      if (!(match = line.match(magic_token_re))) {\n        return rgbe_error(rgbe_format_error, 'bad initial token');\n      }\n\n      header.valid |= RGBE_VALID_PROGRAMTYPE;\n      header.programtype = match[1];\n      header.string += line + '\\n';\n\n      while (true) {\n        line = fgets(buffer);\n        if (false === line) break;\n        header.string += line + '\\n';\n\n        if ('#' === line.charAt(0)) {\n          header.comments += line + '\\n';\n          continue; // comment line\n        }\n\n        if (match = line.match(gamma_re)) {\n          header.gamma = parseFloat(match[1]);\n        }\n\n        if (match = line.match(exposure_re)) {\n          header.exposure = parseFloat(match[1]);\n        }\n\n        if (match = line.match(format_re)) {\n          header.valid |= RGBE_VALID_FORMAT;\n          header.format = match[1]; //'32-bit_rle_rgbe';\n        }\n\n        if (match = line.match(dimensions_re)) {\n          header.valid |= RGBE_VALID_DIMENSIONS;\n          header.height = parseInt(match[1], 10);\n          header.width = parseInt(match[2], 10);\n        }\n\n        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n      }\n\n      if (!(header.valid & RGBE_VALID_FORMAT)) {\n        return rgbe_error(rgbe_format_error, 'missing format specifier');\n      }\n\n      if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n        return rgbe_error(rgbe_format_error, 'missing image size specifier');\n      }\n\n      return header;\n    },\n          RGBE_ReadPixels_RLE = function (buffer, w, h) {\n      const scanline_width = w;\n\n      if ( // run length encoding is not allowed so read flat\n      scanline_width < 8 || scanline_width > 0x7fff || // this file is not run length encoded\n      2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) {\n        // return the flat buffer\n        return new Uint8Array(buffer);\n      }\n\n      if (scanline_width !== (buffer[2] << 8 | buffer[3])) {\n        return rgbe_error(rgbe_format_error, 'wrong scanline width');\n      }\n\n      const data_rgba = new Uint8Array(4 * w * h);\n\n      if (!data_rgba.length) {\n        return rgbe_error(rgbe_memory_error, 'unable to allocate buffer space');\n      }\n\n      let offset = 0,\n          pos = 0;\n      const ptr_end = 4 * scanline_width;\n      const rgbeStart = new Uint8Array(4);\n      const scanline_buffer = new Uint8Array(ptr_end);\n      let num_scanlines = h; // read in each successive scanline\n\n      while (num_scanlines > 0 && pos < buffer.byteLength) {\n        if (pos + 4 > buffer.byteLength) {\n          return rgbe_error(rgbe_read_error);\n        }\n\n        rgbeStart[0] = buffer[pos++];\n        rgbeStart[1] = buffer[pos++];\n        rgbeStart[2] = buffer[pos++];\n        rgbeStart[3] = buffer[pos++];\n\n        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n          return rgbe_error(rgbe_format_error, 'bad rgbe scanline format');\n        } // read each of the four channels for the scanline into the buffer\n        // first red, then green, then blue, then exponent\n\n\n        let ptr = 0,\n            count;\n\n        while (ptr < ptr_end && pos < buffer.byteLength) {\n          count = buffer[pos++];\n          const isEncodedRun = count > 128;\n          if (isEncodedRun) count -= 128;\n\n          if (0 === count || ptr + count > ptr_end) {\n            return rgbe_error(rgbe_format_error, 'bad scanline data');\n          }\n\n          if (isEncodedRun) {\n            // a (encoded) run of the same value\n            const byteValue = buffer[pos++];\n\n            for (let i = 0; i < count; i++) {\n              scanline_buffer[ptr++] = byteValue;\n            } //ptr += count;\n\n          } else {\n            // a literal-run\n            scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n            ptr += count;\n            pos += count;\n          }\n        } // now convert data from buffer into rgba\n        // first red, then green, then blue, then exponent (alpha)\n\n\n        const l = scanline_width; //scanline_buffer.byteLength;\n\n        for (let i = 0; i < l; i++) {\n          let off = 0;\n          data_rgba[offset] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 1] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 2] = scanline_buffer[i + off];\n          off += scanline_width; //1;\n\n          data_rgba[offset + 3] = scanline_buffer[i + off];\n          offset += 4;\n        }\n\n        num_scanlines--;\n      }\n\n      return data_rgba;\n    };\n\n    const RGBEByteToRGBFloat = function (sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3];\n      const scale = Math.pow(2.0, e - 128.0) / 255.0;\n      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n      destArray[destOffset + 3] = 1;\n    };\n\n    const RGBEByteToRGBHalf = function (sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3];\n      const scale = Math.pow(2.0, e - 128.0) / 255.0; // clamping to 65504, the maximum representable value in float16\n\n      destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));\n      destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));\n      destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));\n      destArray[destOffset + 3] = DataUtils.toHalfFloat(1);\n    };\n\n    const byteArray = new Uint8Array(buffer);\n    byteArray.pos = 0;\n    const rgbe_header_info = RGBE_ReadHeader(byteArray);\n\n    if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\n      const w = rgbe_header_info.width,\n            h = rgbe_header_info.height,\n            image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n\n      if (RGBE_RETURN_FAILURE !== image_rgba_data) {\n        let data, format, type;\n        let numElements;\n\n        switch (this.type) {\n          case FloatType:\n            numElements = image_rgba_data.length / 4;\n            const floatArray = new Float32Array(numElements * 4);\n\n            for (let j = 0; j < numElements; j++) {\n              RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);\n            }\n\n            data = floatArray;\n            type = FloatType;\n            break;\n\n          case HalfFloatType:\n            numElements = image_rgba_data.length / 4;\n            const halfArray = new Uint16Array(numElements * 4);\n\n            for (let j = 0; j < numElements; j++) {\n              RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);\n            }\n\n            data = halfArray;\n            type = HalfFloatType;\n            break;\n\n          default:\n            console.error('THREE.RGBELoader: unsupported type: ', this.type);\n            break;\n        }\n\n        return {\n          width: w,\n          height: h,\n          data: data,\n          header: rgbe_header_info.string,\n          gamma: rgbe_header_info.gamma,\n          exposure: rgbe_header_info.exposure,\n          format: format,\n          type: type\n        };\n      }\n    }\n\n    return null;\n  }\n\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case FloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n\n        case HalfFloatType:\n          texture.encoding = LinearEncoding;\n          texture.minFilter = LinearFilter;\n          texture.magFilter = LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n      }\n\n      if (onLoad) onLoad(texture, texData);\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n\n}\n\nexport { RGBELoader };\n","const presetsObj = {\n  sunset: 'venice/venice_sunset_1k.hdr',\n  dawn: 'kiara/kiara_1_dawn_1k.hdr',\n  night: 'dikhololo/dikhololo_night_1k.hdr',\n  warehouse: 'empty-wharehouse/empty_warehouse_01_1k.hdr',\n  forest: 'forrest-slope/forest_slope_1k.hdr',\n  apartment: 'lebombo/lebombo_1k.hdr',\n  studio: 'studio-small-3/studio_small_03_1k.hdr',\n  city: 'potsdamer-platz/potsdamer_platz_1k.hdr',\n  park: 'rooitou/rooitou_park_1k.hdr',\n  lobby: 'st-fagans/st_fagans_interior_1k.hdr'\n};\n\nexport { presetsObj };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\n\nfunction create(type) {\n  const El = type + 'BufferGeometry';\n  return /*#__PURE__*/React.forwardRef(({\n    args,\n    children,\n    ...props\n  }, ref) => /*#__PURE__*/React.createElement(\"mesh\", _extends({\n    ref: ref\n  }, props), /*#__PURE__*/React.createElement(El, {\n    attach: \"geometry\",\n    args: args\n  }), children));\n}\n\nconst Box = create('box');\nconst Circle = create('circle');\nconst Cone = create('cone');\nconst Cylinder = create('cylinder');\nconst Sphere = create('sphere');\nconst Plane = create('plane');\nconst Tube = create('tube');\nconst Torus = create('torus');\nconst TorusKnot = create('torusKnot');\nconst Tetrahedron = create('tetrahedron');\nconst Ring = create('ring');\nconst Polyhedron = create('polyhedron');\nconst Icosahedron = create('icosahedron');\nconst Octahedron = create('octahedron');\nconst Dodecahedron = create('dodecahedron');\nconst Extrude = create('extrude');\nconst Lathe = create('lathe');\n\nexport { Box, Circle, Cone, Cylinder, Dodecahedron, Extrude, Icosahedron, Lathe, Octahedron, Plane, Polyhedron, Ring, Sphere, Tetrahedron, Torus, TorusKnot, Tube };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { useThree, useLoader, useFrame, createPortal } from '@react-three/fiber';\nimport { CubeReflectionMapping, EquirectangularReflectionMapping, Scene, WebGLCubeRenderTarget, HalfFloatType, CubeTextureLoader, BackSide } from 'three';\nimport { RGBELoader } from 'three-stdlib';\nimport { presetsObj } from '../helpers/environment-assets.js';\nimport vertexShader from '../helpers/glsl/GroundProjection.vert.glsl.js';\nimport fragmentShader from '../helpers/glsl/GroundProjection.frag.glsl.js';\nimport { Icosahedron } from './shapes.js';\n\nconst CUBEMAP_ROOT = 'https://market-assets.fra1.cdn.digitaloceanspaces.com/market-assets/hdris/';\n\nconst isCubeTexture = def => def && def.isCubeTexture;\n\nconst isRef = obj => obj.current && obj.current.isScene;\n\nconst resolveScene = scene => isRef(scene) ? scene.current : scene;\n\nfunction EnvironmentMap({\n  scene,\n  background = false,\n  map\n}) {\n  const defaultScene = useThree(state => state.scene);\n  React.useLayoutEffect(() => {\n    if (map) {\n      const target = resolveScene(scene || defaultScene);\n      const oldbg = target.background;\n      const oldenv = target.environment;\n      if (background !== 'only') target.environment = map;\n      if (background) target.background = map;\n      return () => {\n        if (background !== 'only') target.environment = oldenv;\n        if (background) target.background = oldbg;\n      };\n    }\n  }, [defaultScene, scene, map, background]);\n  return null;\n}\nfunction useEnvironment({\n  files = ['/px.png', '/nx.png', '/py.png', '/ny.png', '/pz.png', '/nz.png'],\n  path = '',\n  preset = undefined,\n  extensions\n}) {\n  if (preset) {\n    if (!(preset in presetsObj)) throw new Error('Preset must be one of: ' + Object.keys(presetsObj).join(', '));\n    files = presetsObj[preset];\n    path = CUBEMAP_ROOT;\n  }\n\n  const isCubeMap = Array.isArray(files);\n  const loader = isCubeMap ? CubeTextureLoader : RGBELoader;\n  const loaderResult = useLoader( // @ts-expect-error\n  loader, isCubeMap ? [files] : files, loader => {\n    loader.setPath(path);\n    if (extensions) extensions(loader);\n  });\n  const texture = isCubeMap ? // @ts-ignore\n  loaderResult[0] : loaderResult;\n  texture.mapping = isCubeMap ? CubeReflectionMapping : EquirectangularReflectionMapping;\n  return texture;\n}\nfunction EnvironmentCube({\n  background = false,\n  scene,\n  ...rest\n}) {\n  const texture = useEnvironment(rest);\n  const defaultScene = useThree(state => state.scene);\n  React.useLayoutEffect(() => {\n    const target = resolveScene(scene || defaultScene);\n    const oldbg = target.background;\n    const oldenv = target.environment;\n    if (background !== 'only') target.environment = texture;\n    if (background) target.background = texture;\n    return () => {\n      if (background !== 'only') target.environment = oldenv;\n      if (background) target.background = oldbg;\n    };\n  }, [texture, background, scene, defaultScene]);\n  return null;\n}\nfunction EnvironmentPortal({\n  children,\n  near = 1,\n  far = 1000,\n  resolution = 256,\n  frames = 1,\n  map,\n  background = false,\n  scene,\n  files,\n  path,\n  preset = undefined,\n  extensions\n}) {\n  const gl = useThree(state => state.gl);\n  const defaultScene = useThree(state => state.scene);\n  const camera = React.useRef(null);\n  const [virtualScene] = React.useState(() => new Scene());\n  const fbo = React.useMemo(() => {\n    const fbo = new WebGLCubeRenderTarget(resolution);\n    fbo.texture.type = HalfFloatType;\n    return fbo;\n  }, [resolution]);\n  React.useLayoutEffect(() => {\n    if (frames === 1) camera.current.update(gl, virtualScene);\n    const target = resolveScene(scene || defaultScene);\n    const oldbg = target.background;\n    const oldenv = target.environment;\n    if (background !== 'only') target.environment = fbo.texture;\n    if (background) target.background = fbo.texture;\n    return () => {\n      if (background !== 'only') target.environment = oldenv;\n      if (background) target.background = oldbg;\n    };\n  }, [children, virtualScene, fbo.texture, scene, defaultScene, background, frames, gl]);\n  let count = 1;\n  useFrame(() => {\n    if (frames === Infinity || count < frames) {\n      camera.current.update(gl, virtualScene);\n      count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(React.Fragment, null, createPortal( /*#__PURE__*/React.createElement(React.Fragment, null, children, /*#__PURE__*/React.createElement(\"cubeCamera\", {\n    ref: camera,\n    args: [near, far, fbo]\n  }), files || preset ? /*#__PURE__*/React.createElement(EnvironmentCube, {\n    background: true,\n    files: files,\n    preset: preset,\n    path: path,\n    extensions: extensions\n  }) : map ? /*#__PURE__*/React.createElement(EnvironmentMap, {\n    background: true,\n    map: map,\n    extensions: extensions\n  }) : null), virtualScene));\n}\n\nfunction EnvironmentGround(props) {\n  var _props$ground, _props$ground2, _scale, _props$ground3;\n\n  const textureDefault = useEnvironment(props);\n  const texture = props.map || textureDefault;\n  const isCubeMap = isCubeTexture(texture);\n  const defines = React.useMemo(() => {\n    var _ref, _texture$image$;\n\n    const w = (_ref = isCubeMap ? (_texture$image$ = texture.image[0]) == null ? void 0 : _texture$image$.width : texture.image.width) !== null && _ref !== void 0 ? _ref : 1024;\n    const cubeSize = w / 4;\n\n    const _lodMax = Math.floor(Math.log2(cubeSize));\n\n    const _cubeSize = Math.pow(2, _lodMax);\n\n    const width = 3 * Math.max(_cubeSize, 16 * 7);\n    const height = 4 * _cubeSize;\n    return [isCubeMap ? `#define ENVMAP_TYPE_CUBE` : '', `#define CUBEUV_TEXEL_WIDTH ${1.0 / width}`, `#define CUBEUV_TEXEL_HEIGHT ${1.0 / height}`, `#define CUBEUV_MAX_MIP ${_lodMax}.0`, ``];\n  }, []);\n  const fragment = React.useMemo(() => defines.join('\\n') + fragmentShader, [defines]);\n  const uniforms = React.useMemo(() => ({\n    cubemap: {\n      value: null\n    },\n    height: {\n      value: 15\n    },\n    radius: {\n      value: 60\n    }\n  }), []);\n  const mat = React.useRef(null);\n  const height = (_props$ground = props.ground) == null ? void 0 : _props$ground.height;\n  const radius = (_props$ground2 = props.ground) == null ? void 0 : _props$ground2.radius;\n  const scale = (_scale = (_props$ground3 = props.ground) == null ? void 0 : _props$ground3.scale) !== null && _scale !== void 0 ? _scale : 1000;\n  React.useEffect(() => void (height && (mat.current.uniforms.height.value = height)), [height]);\n  React.useEffect(() => void (radius && (mat.current.uniforms.radius.value = radius)), [radius]);\n  React.useEffect(() => void (mat.current.uniforms.cubemap.value = texture), [texture]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(EnvironmentMap, _extends({}, props, {\n    map: texture\n  })), /*#__PURE__*/React.createElement(Icosahedron, {\n    scale: scale,\n    args: [1, 16]\n  }, /*#__PURE__*/React.createElement(\"shaderMaterial\", {\n    ref: mat,\n    side: BackSide,\n    vertexShader: vertexShader,\n    fragmentShader: fragment,\n    uniforms: uniforms,\n    depthTest: false\n  })));\n}\n\nfunction Environment(props) {\n  return props.ground ? /*#__PURE__*/React.createElement(EnvironmentGround, props) : props.map ? /*#__PURE__*/React.createElement(EnvironmentMap, props) : props.children ? /*#__PURE__*/React.createElement(EnvironmentPortal, props) : /*#__PURE__*/React.createElement(EnvironmentCube, props);\n}\n\nexport { Environment, EnvironmentCube, EnvironmentMap, EnvironmentPortal, useEnvironment };\n","var fragmentShader = \"#define GLSLIFY 1\\n#define ENVMAP_TYPE_CUBE_UV\\nvarying vec3 vWorldPosition;uniform float radius;uniform float height;\\n#ifdef ENVMAP_TYPE_CUBE\\nuniform samplerCube cubemap;\\n#else\\nuniform sampler2D cubemap;\\n#endif\\nfloat diskIntersect(in vec3 ro,in vec3 rd,vec3 c,vec3 n,float r){vec3 o=ro-c;float t=-dot(n,o)/dot(rd,n);vec3 q=o+rd*t;return(dot(q,q)<r*r)? t : 1e6;}float sphereIntersect(in vec3 ro,in vec3 rd,in vec3 ce,float ra){vec3 oc=ro-ce;float b=dot(oc,rd);float c=dot(oc,oc)-ra*ra;float h=b*b-c;if(h<0.0)-1.0;h=sqrt(h);return-b+h;}vec3 project(){vec3 p=normalize(vWorldPosition);vec3 camPos=cameraPosition;camPos.y-=height;float intersection=sphereIntersect(camPos,p,vec3(0.),radius);if(intersection>0.){vec3 h=vec3(0.0,-height,0.0);float intersection2=diskIntersect(camPos,p,h,vec3(0.0,-1.0,0.0),radius);p=(camPos+min(intersection,intersection2)*p)/radius;}else{p=vec3(0.0,1.0,0.0);}return p;}\\n#include <common>\\n#include <cube_uv_reflection_fragment>\\nvoid main(){vec3 projectedWorldPosition=project();\\n#ifdef ENVMAP_TYPE_CUBE\\nvec3 outcolor=textureCube(cubemap,projectedWorldPosition).rgb;\\n#else\\nvec3 direction=normalize(projectedWorldPosition);vec2 uv=equirectUv(direction);vec3 outcolor=texture2D(cubemap,uv).rgb;\\n#endif\\ngl_FragColor=vec4(outcolor,1.0);\\n#include <tonemapping_fragment>\\n#include <encodings_fragment>\\n}\"; // eslint-disable-line\n\nexport { fragmentShader as default };\n","var vertexShader = \"#define GLSLIFY 1\\nvarying vec3 vWorldPosition;void main(){vec4 worldPosition=modelMatrix*vec4(position,1.0);vWorldPosition=worldPosition.xyz;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}\"; // eslint-disable-line\n\nexport { vertexShader as default };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree } from '@react-three/fiber';\nimport { Environment } from './Environment.js';\nimport { ContactShadows } from './ContactShadows.js';\n\nconst presets = {\n  rembrandt: {\n    main: [1, 2, 1],\n    fill: [-2, -0.5, -2]\n  },\n  portrait: {\n    main: [-1, 2, 0.5],\n    fill: [-1, 0.5, -1.5]\n  },\n  upfront: {\n    main: [0, 2, 1],\n    fill: [-1, 0.5, -1.5]\n  },\n  soft: {\n    main: [-2, 4, 4],\n    fill: [-1, 0.5, -1.5]\n  }\n};\nfunction Stage({\n  children,\n  controls,\n  shadows = true,\n  adjustCamera = true,\n  environment = 'city',\n  intensity = 1,\n  preset = 'rembrandt',\n  shadowBias = 0,\n  contactShadow = {\n    blur: 2,\n    opacity: 0.5,\n    position: [0, 0, 0]\n  },\n  ...props\n}) {\n  const config = presets[preset];\n  const camera = useThree(state => state.camera); // @ts-expect-error new in @react-three/fiber@7.0.5\n\n  const defaultControls = useThree(state => state.controls);\n  const outer = React.useRef(null);\n  const inner = React.useRef(null);\n  const [{\n    radius,\n    width,\n    height\n  }, set] = React.useState({\n    radius: 0,\n    width: 0,\n    height: 0\n  });\n  React.useLayoutEffect(() => {\n    outer.current.position.set(0, 0, 0);\n    outer.current.updateWorldMatrix(true, true);\n    const box3 = new THREE.Box3().setFromObject(inner.current);\n    const center = new THREE.Vector3();\n    const sphere = new THREE.Sphere();\n    const height = box3.max.y - box3.min.y;\n    const width = box3.max.x - box3.min.x;\n    box3.getCenter(center);\n    box3.getBoundingSphere(sphere);\n    set({\n      radius: sphere.radius,\n      width,\n      height\n    });\n    outer.current.position.set(-center.x, -center.y + height / 2, -center.z);\n  }, [children]);\n  React.useLayoutEffect(() => {\n    if (adjustCamera) {\n      const y = radius / (height > width ? 1.5 : 2.5);\n      camera.position.set(0, radius * 0.5, radius * 2.5);\n      camera.near = 0.1;\n      camera.far = Math.max(5000, radius * 4);\n      camera.lookAt(0, y, 0);\n      const ctrl = defaultControls || (controls == null ? void 0 : controls.current);\n\n      if (ctrl) {\n        ctrl.target.set(0, y, 0);\n        ctrl.update();\n      }\n    }\n  }, [defaultControls, radius, height, width, adjustCamera]);\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(\"group\", {\n    ref: outer\n  }, /*#__PURE__*/React.createElement(\"group\", {\n    ref: inner\n  }, children)), contactShadow && /*#__PURE__*/React.createElement(ContactShadows, _extends({\n    scale: radius * 2,\n    far: radius / 2\n  }, contactShadow)), environment && /*#__PURE__*/React.createElement(Environment, {\n    preset: environment\n  }), /*#__PURE__*/React.createElement(\"ambientLight\", {\n    intensity: intensity / 3\n  }), /*#__PURE__*/React.createElement(\"spotLight\", {\n    penumbra: 1,\n    position: [config.main[0] * radius, config.main[1] * radius, config.main[2] * radius],\n    intensity: intensity * 2,\n    castShadow: shadows,\n    \"shadow-bias\": shadowBias\n  }), /*#__PURE__*/React.createElement(\"pointLight\", {\n    position: [config.fill[0] * radius, config.fill[1] * radius, config.fill[2] * radius],\n    intensity: intensity\n  }));\n}\n\nexport { Stage };\n"],"names":["HorizontalBlurShader","uniforms","tDiffuse","value","h","vertexShader","fragmentShader","VerticalBlurShader","v","ContactShadows","React","ref","scale","frames","Infinity","opacity","width","height","blur","far","resolution","smooth","color","depthWrite","renderOrder","props","scene","useThree","state","gl","shadowCamera","Array","isArray","renderTarget","THREE","renderTargetBlur","texture","generateMipmaps","planeGeometry","rotateX","Math","PI","blurPlane","depthMaterial","depthTest","onBeforeCompile","shader","ucolor","convertSRGBToLinear","replace","horizontalBlurMaterial","verticalBlurMaterial","blurShadows","visible","material","setRenderTarget","render","current","count","useFrame","initialBackground","background","initialOverrideMaterial","overrideMaterial","_extends","geometry","rotation","map","outputEncoding","transparent","args","RGBELoader","manager","type","HalfFloatType","buffer","rgbe_error","rgbe_error_code","msg","console","error","fgets","lineLimit","consume","p","pos","i","len","s","chunk","String","fromCharCode","apply","Uint16Array","subarray","indexOf","byteLength","length","slice","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","e","pow","RGBEByteToRGBHalf","DataUtils","min","byteArray","Uint8Array","rgbe_header_info","line","match","gamma_re","exposure_re","format_re","dimensions_re","header","valid","string","comments","programtype","format","gamma","exposure","charAt","parseFloat","parseInt","RGBE_ReadHeader","w","image_rgba_data","scanline_width","data_rgba","offset","ptr_end","rgbeStart","scanline_buffer","num_scanlines","ptr","isEncodedRun","byteValue","set","l","off","RGBE_ReadPixels_RLE","data","numElements","this","FloatType","floatArray","Float32Array","j","halfArray","url","onLoad","onProgress","onError","texData","encoding","LinearEncoding","minFilter","LinearFilter","magFilter","flipY","DataTextureLoader","presetsObj","sunset","dawn","night","warehouse","forest","apartment","studio","city","park","lobby","create","El","children","attach","Icosahedron","resolveScene","obj","isScene","EnvironmentMap","defaultScene","target","oldbg","oldenv","environment","useEnvironment","files","path","preset","undefined","extensions","Error","Object","keys","join","isCubeMap","loader","CubeTextureLoader","loaderResult","useLoader","setPath","mapping","CubeReflectionMapping","EquirectangularReflectionMapping","EnvironmentCube","EnvironmentPortal","near","camera","Scene","virtualScene","fbo","WebGLCubeRenderTarget","update","createPortal","EnvironmentGround","_props$ground","_props$ground2","_scale","_props$ground3","def","textureDefault","isCubeTexture","defines","_ref","_texture$image$","cubeSize","image","_lodMax","floor","log2","_cubeSize","max","fragment","cubemap","radius","mat","ground","side","BackSide","Environment","presets","rembrandt","main","fill","portrait","upfront","soft","Stage","controls","shadows","adjustCamera","intensity","shadowBias","contactShadow","position","config","defaultControls","outer","inner","updateWorldMatrix","box3","setFromObject","center","sphere","y","x","getCenter","getBoundingSphere","z","lookAt","ctrl","penumbra","castShadow"],"sourceRoot":""}