{"version":3,"file":"static/js/5955.30838961.chunk.js","mappings":"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","sources":["../node_modules/@use-gesture/core/dist/maths-b2a210f4.esm.js","../node_modules/@use-gesture/core/dist/actions-8e12537b.esm.js","../node_modules/@use-gesture/core/dist/use-gesture-core.esm.js","../node_modules/@use-gesture/react/dist/use-gesture-react.esm.js"],"sourcesContent":["function clamp(v, min, max) {\n  return Math.max(min, Math.min(v, max));\n}\nconst V = {\n  toVector(v, fallback) {\n    if (v === undefined) v = fallback;\n    return Array.isArray(v) ? v : [v, v];\n  },\n\n  add(v1, v2) {\n    return [v1[0] + v2[0], v1[1] + v2[1]];\n  },\n\n  sub(v1, v2) {\n    return [v1[0] - v2[0], v1[1] - v2[1]];\n  },\n\n  addTo(v1, v2) {\n    v1[0] += v2[0];\n    v1[1] += v2[1];\n  },\n\n  subTo(v1, v2) {\n    v1[0] -= v2[0];\n    v1[1] -= v2[1];\n  }\n\n};\n\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\n\nfunction rubberbandIfOutOfBounds(position, min, max, constant = 0.15) {\n  if (constant === 0) return clamp(position, min, max);\n  if (position < min) return -rubberband(min - position, max - min, constant) + min;\n  if (position > max) return +rubberband(position - max, max - min, constant) + max;\n  return position;\n}\nfunction computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {\n  const [[X0, X1], [Y0, Y1]] = bounds;\n  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];\n}\n\nexport { V, computeRubberband as c, rubberbandIfOutOfBounds as r };\n","import { V, c as computeRubberband } from './maths-b2a210f4.esm.js';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nconst EVENT_TYPE_MAP = {\n  pointer: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  mouse: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  touch: {\n    start: 'start',\n    change: 'move',\n    end: 'end'\n  },\n  gesture: {\n    start: 'start',\n    change: 'change',\n    end: 'end'\n  }\n};\n\nfunction capitalize(string) {\n  if (!string) return '';\n  return string[0].toUpperCase() + string.slice(1);\n}\n\nfunction toHandlerProp(device, action = '', capture = false) {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return 'on' + capitalize(device) + capitalize(actionKey) + (capture ? 'Capture' : '');\n}\nconst pointerCaptureEvents = ['gotpointercapture', 'lostpointercapture'];\nfunction parseProp(prop) {\n  let eventKey = prop.substring(2).toLowerCase();\n  const passive = !!~eventKey.indexOf('passive');\n  if (passive) eventKey = eventKey.replace('passive', '');\n  const captureKey = pointerCaptureEvents.includes(eventKey) ? 'capturecapture' : 'capture';\n  const capture = !!~eventKey.indexOf(captureKey);\n  if (capture) eventKey = eventKey.replace('capture', '');\n  return {\n    device: eventKey,\n    capture,\n    passive\n  };\n}\nfunction toDomEventType(device, action = '') {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return device + actionKey;\n}\nfunction isTouch(event) {\n  return 'touches' in event;\n}\nfunction getPointerType(event) {\n  if (isTouch(event)) return 'touch';\n  if ('pointerType' in event) return event.pointerType;\n  return 'mouse';\n}\n\nfunction getCurrentTargetTouchList(event) {\n  return Array.from(event.touches).filter(e => {\n    var _event$currentTarget, _event$currentTarget$;\n\n    return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));\n  });\n}\n\nfunction getTouchList(event) {\n  return event.type === 'touchend' || event.type === 'touchcancel' ? event.changedTouches : event.targetTouches;\n}\n\nfunction getValueEvent(event) {\n  return isTouch(event) ? getTouchList(event)[0] : event;\n}\n\nfunction distanceAngle(P1, P2) {\n  const dx = P2.clientX - P1.clientX;\n  const dy = P2.clientY - P1.clientY;\n  const cx = (P2.clientX + P1.clientX) / 2;\n  const cy = (P2.clientY + P1.clientY) / 2;\n  const distance = Math.hypot(dx, dy);\n  const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;\n  const origin = [cx, cy];\n  return {\n    angle,\n    distance,\n    origin\n  };\n}\nfunction touchIds(event) {\n  return getCurrentTargetTouchList(event).map(touch => touch.identifier);\n}\nfunction touchDistanceAngle(event, ids) {\n  const [P1, P2] = Array.from(event.touches).filter(touch => ids.includes(touch.identifier));\n  return distanceAngle(P1, P2);\n}\nfunction pointerId(event) {\n  const valueEvent = getValueEvent(event);\n  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;\n}\nfunction pointerValues(event) {\n  const valueEvent = getValueEvent(event);\n  return [valueEvent.clientX, valueEvent.clientY];\n}\nconst LINE_HEIGHT = 40;\nconst PAGE_HEIGHT = 800;\nfunction wheelValues(event) {\n  let {\n    deltaX,\n    deltaY,\n    deltaMode\n  } = event;\n\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT;\n    deltaY *= LINE_HEIGHT;\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT;\n    deltaY *= PAGE_HEIGHT;\n  }\n\n  return [deltaX, deltaY];\n}\nfunction scrollValues(event) {\n  var _ref, _ref2;\n\n  const {\n    scrollX,\n    scrollY,\n    scrollLeft,\n    scrollTop\n  } = event.currentTarget;\n  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];\n}\nfunction getEventDetails(event) {\n  const payload = {};\n  if ('buttons' in event) payload.buttons = event.buttons;\n\n  if ('shiftKey' in event) {\n    const {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    } = event;\n    Object.assign(payload, {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    });\n  }\n\n  return payload;\n}\n\nfunction call(v, ...args) {\n  if (typeof v === 'function') {\n    return v(...args);\n  } else {\n    return v;\n  }\n}\nfunction noop() {}\nfunction chain(...fns) {\n  if (fns.length === 0) return noop;\n  if (fns.length === 1) return fns[0];\n  return function () {\n    let result;\n\n    for (const fn of fns) {\n      result = fn.apply(this, arguments) || result;\n    }\n\n    return result;\n  };\n}\nfunction assignDefault(value, fallback) {\n  return Object.assign({}, fallback, value || {});\n}\n\nconst BEFORE_LAST_KINEMATICS_DELAY = 32;\nclass Engine {\n  constructor(ctrl, args, key) {\n    this.ctrl = ctrl;\n    this.args = args;\n    this.key = key;\n\n    if (!this.state) {\n      this.state = {};\n      this.computeValues([0, 0]);\n      this.computeInitial();\n      if (this.init) this.init();\n      this.reset();\n    }\n  }\n\n  get state() {\n    return this.ctrl.state[this.key];\n  }\n\n  set state(state) {\n    this.ctrl.state[this.key] = state;\n  }\n\n  get shared() {\n    return this.ctrl.state.shared;\n  }\n\n  get eventStore() {\n    return this.ctrl.gestureEventStores[this.key];\n  }\n\n  get timeoutStore() {\n    return this.ctrl.gestureTimeoutStores[this.key];\n  }\n\n  get config() {\n    return this.ctrl.config[this.key];\n  }\n\n  get sharedConfig() {\n    return this.ctrl.config.shared;\n  }\n\n  get handler() {\n    return this.ctrl.handlers[this.key];\n  }\n\n  reset() {\n    const {\n      state,\n      shared,\n      ingKey,\n      args\n    } = this;\n    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;\n    state._step = [false, false];\n    state.intentional = false;\n    state._movement = [0, 0];\n    state._distance = [0, 0];\n    state._direction = [0, 0];\n    state._delta = [0, 0];\n    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];\n    state.args = args;\n    state.axis = undefined;\n    state.memo = undefined;\n    state.elapsedTime = 0;\n    state.direction = [0, 0];\n    state.distance = [0, 0];\n    state.overflow = [0, 0];\n    state._movementBound = [false, false];\n    state.velocity = [0, 0];\n    state.movement = [0, 0];\n    state.delta = [0, 0];\n    state.timeStamp = 0;\n  }\n\n  start(event) {\n    const state = this.state;\n    const config = this.config;\n\n    if (!state._active) {\n      this.reset();\n      this.computeInitial();\n      state._active = true;\n      state.target = event.target;\n      state.currentTarget = event.currentTarget;\n      state.lastOffset = config.from ? call(config.from, state) : state.offset;\n      state.offset = state.lastOffset;\n    }\n\n    state.startTime = state.timeStamp = event.timeStamp;\n  }\n\n  computeValues(values) {\n    const state = this.state;\n    state._values = values;\n    state.values = this.config.transform(values);\n  }\n\n  computeInitial() {\n    const state = this.state;\n    state._initial = state._values;\n    state.initial = state.values;\n  }\n\n  compute(event) {\n    const {\n      state,\n      config,\n      shared\n    } = this;\n    state.args = this.args;\n    let dt = 0;\n\n    if (event) {\n      state.event = event;\n      if (config.preventDefault && event.cancelable) state.event.preventDefault();\n      state.type = event.type;\n      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;\n      shared.locked = !!document.pointerLockElement;\n      Object.assign(shared, getEventDetails(event));\n      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;\n      dt = event.timeStamp - state.timeStamp;\n      state.timeStamp = event.timeStamp;\n      state.elapsedTime = state.timeStamp - state.startTime;\n    }\n\n    if (state._active) {\n      const _absoluteDelta = state._delta.map(Math.abs);\n\n      V.addTo(state._distance, _absoluteDelta);\n    }\n\n    if (this.axisIntent) this.axisIntent(event);\n    const [_m0, _m1] = state._movement;\n    const [t0, t1] = config.threshold;\n    const {\n      _step,\n      values\n    } = state;\n\n    if (config.hasCustomTransform) {\n      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0];\n      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1];\n    } else {\n      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;\n      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;\n    }\n\n    state.intentional = _step[0] !== false || _step[1] !== false;\n    if (!state.intentional) return;\n    const movement = [0, 0];\n\n    if (config.hasCustomTransform) {\n      const [v0, v1] = values;\n      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;\n    } else {\n      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;\n    }\n\n    if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement);\n    const previousOffset = state.offset;\n    const gestureIsActive = state._active && !state._blocked || state.active;\n\n    if (gestureIsActive) {\n      state.first = state._active && !state.active;\n      state.last = !state._active && state.active;\n      state.active = shared[this.ingKey] = state._active;\n\n      if (event) {\n        if (state.first) {\n          if ('bounds' in config) state._bounds = call(config.bounds, state);\n          if (this.setup) this.setup();\n        }\n\n        state.movement = movement;\n        this.computeOffset();\n      }\n    }\n\n    const [ox, oy] = state.offset;\n    const [[x0, x1], [y0, y1]] = state._bounds;\n    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];\n    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;\n    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;\n    const rubberband = state._active ? config.rubberband || [0, 0] : [0, 0];\n    state.offset = computeRubberband(state._bounds, state.offset, rubberband);\n    state.delta = V.sub(state.offset, previousOffset);\n    this.computeMovement();\n\n    if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {\n      state.delta = V.sub(state.offset, previousOffset);\n      const absoluteDelta = state.delta.map(Math.abs);\n      V.addTo(state.distance, absoluteDelta);\n      state.direction = state.delta.map(Math.sign);\n      state._direction = state._delta.map(Math.sign);\n\n      if (!state.first && dt > 0) {\n        state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];\n      }\n    }\n  }\n\n  emit() {\n    const state = this.state;\n    const shared = this.shared;\n    const config = this.config;\n    if (!state._active) this.clean();\n    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return;\n    const memo = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {\n      [this.aliasKey]: state.values\n    }));\n    if (memo !== undefined) state.memo = memo;\n  }\n\n  clean() {\n    this.eventStore.clean();\n    this.timeoutStore.clean();\n  }\n\n}\n\nfunction selectAxis([dx, dy], threshold) {\n  const absDx = Math.abs(dx);\n  const absDy = Math.abs(dy);\n\n  if (absDx > absDy && absDx > threshold) {\n    return 'x';\n  }\n\n  if (absDy > absDx && absDy > threshold) {\n    return 'y';\n  }\n\n  return undefined;\n}\n\nclass CoordinatesEngine extends Engine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"aliasKey\", 'xy');\n  }\n\n  reset() {\n    super.reset();\n    this.state.axis = undefined;\n  }\n\n  init() {\n    this.state.offset = [0, 0];\n    this.state.lastOffset = [0, 0];\n  }\n\n  computeOffset() {\n    this.state.offset = V.add(this.state.lastOffset, this.state.movement);\n  }\n\n  computeMovement() {\n    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);\n  }\n\n  axisIntent(event) {\n    const state = this.state;\n    const config = this.config;\n\n    if (!state.axis && event) {\n      const threshold = typeof config.axisThreshold === 'object' ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;\n      state.axis = selectAxis(state._movement, threshold);\n    }\n\n    state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;\n  }\n\n  restrictToAxis(v) {\n    if (this.config.axis || this.config.lockDirection) {\n      switch (this.state.axis) {\n        case 'x':\n          v[1] = 0;\n          break;\n\n        case 'y':\n          v[0] = 0;\n          break;\n      }\n    }\n  }\n\n}\n\nconst identity = v => v;\nconst DEFAULT_RUBBERBAND = 0.15;\nconst commonConfigResolver = {\n  enabled(value = true) {\n    return value;\n  },\n\n  preventDefault(value = false) {\n    return value;\n  },\n\n  triggerAllEvents(value = false) {\n    return value;\n  },\n\n  rubberband(value = 0) {\n    switch (value) {\n      case true:\n        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];\n\n      case false:\n        return [0, 0];\n\n      default:\n        return V.toVector(value);\n    }\n  },\n\n  from(value) {\n    if (typeof value === 'function') return value;\n    if (value != null) return V.toVector(value);\n  },\n\n  transform(value, _k, config) {\n    const transform = value || config.shared.transform;\n    this.hasCustomTransform = !!transform;\n\n    if (process.env.NODE_ENV === 'development') {\n      const originalTransform = transform || identity;\n      return v => {\n        const r = originalTransform(v);\n\n        if (!isFinite(r[0]) || !isFinite(r[1])) {\n          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r[0]},${[1]}]`);\n        }\n\n        return r;\n      };\n    }\n\n    return transform || identity;\n  },\n\n  threshold(value) {\n    return V.toVector(value, 0);\n  }\n\n};\n\nif (process.env.NODE_ENV === 'development') {\n  Object.assign(commonConfigResolver, {\n    domTarget(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n      }\n\n      return NaN;\n    },\n\n    lockDirection(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`lockDirection\\` option has been merged with \\`axis\\`. Use it as in \\`{ axis: 'lock' }\\``);\n      }\n\n      return NaN;\n    },\n\n    initial(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`initial\\` option has been renamed to \\`from\\`.`);\n      }\n\n      return NaN;\n    }\n\n  });\n}\n\nconst DEFAULT_AXIS_THRESHOLD = 0;\nconst coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  axis(_v, _k, {\n    axis\n  }) {\n    this.lockDirection = axis === 'lock';\n    if (!this.lockDirection) return axis;\n  },\n\n  axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {\n    return value;\n  },\n\n  bounds(value = {}) {\n    if (typeof value === 'function') {\n      return state => coordinatesConfigResolver.bounds(value(state));\n    }\n\n    if ('current' in value) {\n      return () => value.current;\n    }\n\n    if (typeof HTMLElement === 'function' && value instanceof HTMLElement) {\n      return value;\n    }\n\n    const {\n      left = -Infinity,\n      right = Infinity,\n      top = -Infinity,\n      bottom = Infinity\n    } = value;\n    return [[left, right], [top, bottom]];\n  }\n\n});\n\nconst DISPLACEMENT = 10;\nconst KEYS_DELTA_MAP = {\n  ArrowRight: (factor = 1) => [DISPLACEMENT * factor, 0],\n  ArrowLeft: (factor = 1) => [-DISPLACEMENT * factor, 0],\n  ArrowUp: (factor = 1) => [0, -DISPLACEMENT * factor],\n  ArrowDown: (factor = 1) => [0, DISPLACEMENT * factor]\n};\nclass DragEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'dragging');\n  }\n\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._pointerId = undefined;\n    state._pointerActive = false;\n    state._keyboardActive = false;\n    state._preventScroll = false;\n    state._delayed = false;\n    state.swipe = [0, 0];\n    state.tap = false;\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n  }\n\n  setup() {\n    const state = this.state;\n\n    if (state._bounds instanceof HTMLElement) {\n      const boundRect = state._bounds.getBoundingClientRect();\n\n      const targetRect = state.currentTarget.getBoundingClientRect();\n      const _bounds = {\n        left: boundRect.left - targetRect.left + state.offset[0],\n        right: boundRect.right - targetRect.right + state.offset[0],\n        top: boundRect.top - targetRect.top + state.offset[1],\n        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]\n      };\n      state._bounds = coordinatesConfigResolver.bounds(_bounds);\n    }\n  }\n\n  cancel() {\n    const state = this.state;\n    if (state.canceled) return;\n    state.canceled = true;\n    state._active = false;\n    setTimeout(() => {\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n\n  setActive() {\n    this.state._active = this.state._pointerActive || this.state._keyboardActive;\n  }\n\n  clean() {\n    this.pointerClean();\n    this.state._pointerActive = false;\n    this.state._keyboardActive = false;\n    super.clean();\n  }\n\n  pointerDown(event) {\n    const config = this.config;\n    const state = this.state;\n    if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons)) return;\n    this.ctrl.setEventIds(event);\n\n    if (config.pointerCapture) {\n      event.target.setPointerCapture(event.pointerId);\n    }\n\n    if (state._pointerActive) return;\n    this.start(event);\n    this.setupPointer(event);\n    state._pointerId = pointerId(event);\n    state._pointerActive = true;\n    this.computeValues(pointerValues(event));\n    this.computeInitial();\n\n    if (config.preventScrollAxis && getPointerType(event) !== 'mouse') {\n      state._active = false;\n      this.setupScrollPrevention(event);\n    } else if (config.delay > 0) {\n      this.setupDelayTrigger(event);\n\n      if (config.triggerAllEvents) {\n        this.compute(event);\n        this.emit();\n      }\n    } else {\n      this.startPointerDrag(event);\n    }\n  }\n\n  startPointerDrag(event) {\n    const state = this.state;\n    state._active = true;\n    state._preventScroll = true;\n    state._delayed = false;\n    this.compute(event);\n    this.emit();\n  }\n\n  pointerMove(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state._pointerActive) return;\n    if (state.type === event.type && event.timeStamp === state.timeStamp) return;\n    const id = pointerId(event);\n    if (state._pointerId !== undefined && id !== state._pointerId) return;\n\n    const _values = pointerValues(event);\n\n    if (document.pointerLockElement === event.target) {\n      state._delta = [event.movementX, event.movementY];\n    } else {\n      state._delta = V.sub(_values, state._values);\n      this.computeValues(_values);\n    }\n\n    V.addTo(state._movement, state._delta);\n    this.compute(event);\n\n    if (state._delayed && state.intentional) {\n      this.timeoutStore.remove('dragDelay');\n      state.active = false;\n      this.startPointerDrag(event);\n      return;\n    }\n\n    if (config.preventScrollAxis && !state._preventScroll) {\n      if (state.axis) {\n        if (state.axis === config.preventScrollAxis || config.preventScrollAxis === 'xy') {\n          state._active = false;\n          this.clean();\n          return;\n        } else {\n          this.timeoutStore.remove('startPointerDrag');\n          this.startPointerDrag(event);\n          return;\n        }\n      } else {\n        return;\n      }\n    }\n\n    this.emit();\n  }\n\n  pointerUp(event) {\n    this.ctrl.setEventIds(event);\n\n    try {\n      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {\n        ;\n        event.target.releasePointerCapture(event.pointerId);\n      }\n    } catch (_unused) {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \\`@react-three/fiber\\`. \\n\\nPlease upgrade to the latest version.`);\n      }\n    }\n\n    const state = this.state;\n    const config = this.config;\n    if (!state._active || !state._pointerActive) return;\n    const id = pointerId(event);\n    if (state._pointerId !== undefined && id !== state._pointerId) return;\n    this.state._pointerActive = false;\n    this.setActive();\n    this.compute(event);\n    const [dx, dy] = state._distance;\n    state.tap = dx <= config.tapsThreshold && dy <= config.tapsThreshold;\n\n    if (state.tap && config.filterTaps) {\n      state._force = true;\n    } else {\n      const [dirx, diry] = state.direction;\n      const [vx, vy] = state.velocity;\n      const [mx, my] = state.movement;\n      const [svx, svy] = config.swipe.velocity;\n      const [sx, sy] = config.swipe.distance;\n      const sdt = config.swipe.duration;\n\n      if (state.elapsedTime < sdt) {\n        if (Math.abs(vx) > svx && Math.abs(mx) > sx) state.swipe[0] = dirx;\n        if (Math.abs(vy) > svy && Math.abs(my) > sy) state.swipe[1] = diry;\n      }\n    }\n\n    this.emit();\n  }\n\n  pointerClick(event) {\n    if (!this.state.tap) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n\n  setupPointer(event) {\n    const config = this.config;\n    const device = config.device;\n\n    if (process.env.NODE_ENV === 'development') {\n      try {\n        if (device === 'pointer' && config.preventScrollDelay === undefined) {\n          const currentTarget = 'uv' in event ? event.sourceEvent.currentTarget : event.currentTarget;\n          const style = window.getComputedStyle(currentTarget);\n\n          if (style.touchAction === 'auto') {\n            console.warn(`[@use-gesture]: The drag target has its \\`touch-action\\` style property set to \\`auto\\`. It is recommended to add \\`touch-action: 'none'\\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\\n\\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);\n          }\n        }\n      } catch (_unused2) {}\n    }\n\n    if (config.pointerLock) {\n      event.currentTarget.requestPointerLock();\n    }\n\n    if (!config.pointerCapture) {\n      this.eventStore.add(this.sharedConfig.window, device, 'change', this.pointerMove.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, 'end', this.pointerUp.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, 'cancel', this.pointerUp.bind(this));\n    }\n  }\n\n  pointerClean() {\n    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {\n      document.exitPointerLock();\n    }\n  }\n\n  preventScroll(event) {\n    if (this.state._preventScroll && event.cancelable) {\n      event.preventDefault();\n    }\n  }\n\n  setupScrollPrevention(event) {\n    persistEvent(event);\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'change', this.preventScroll.bind(this), {\n      passive: false\n    });\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'end', this.clean.bind(this));\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'cancel', this.clean.bind(this));\n    this.timeoutStore.add('startPointerDrag', this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);\n  }\n\n  setupDelayTrigger(event) {\n    this.state._delayed = true;\n    this.timeoutStore.add('dragDelay', () => {\n      this.state._step = [0, 0];\n      this.startPointerDrag(event);\n    }, this.config.delay);\n  }\n\n  keyDown(event) {\n    const deltaFn = KEYS_DELTA_MAP[event.key];\n\n    if (deltaFn) {\n      const state = this.state;\n      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;\n      state._delta = deltaFn(factor);\n      this.start(event);\n      state._keyboardActive = true;\n      V.addTo(state._movement, state._delta);\n      this.compute(event);\n      this.emit();\n    }\n  }\n\n  keyUp(event) {\n    if (!(event.key in KEYS_DELTA_MAP)) return;\n    this.state._keyboardActive = false;\n    this.setActive();\n    this.compute(event);\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    const device = this.config.device;\n    bindFunction(device, 'start', this.pointerDown.bind(this));\n\n    if (this.config.pointerCapture) {\n      bindFunction(device, 'change', this.pointerMove.bind(this));\n      bindFunction(device, 'end', this.pointerUp.bind(this));\n      bindFunction(device, 'cancel', this.pointerUp.bind(this));\n      bindFunction('lostPointerCapture', '', this.pointerUp.bind(this));\n    }\n\n    bindFunction('key', 'down', this.keyDown.bind(this));\n    bindFunction('key', 'up', this.keyUp.bind(this));\n\n    if (this.config.filterTaps) {\n      bindFunction('click', '', this.pointerClick.bind(this), {\n        capture: true,\n        passive: false\n      });\n    }\n  }\n\n}\n\nfunction persistEvent(event) {\n  'persist' in event && typeof event.persist === 'function' && event.persist();\n}\n\nconst isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement;\n\nfunction supportsTouchEvents() {\n  return isBrowser && 'ontouchstart' in window;\n}\n\nfunction isTouchScreen() {\n  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;\n}\n\nfunction supportsPointerEvents() {\n  return isBrowser && 'onpointerdown' in window;\n}\n\nfunction supportsPointerLock() {\n  return isBrowser && 'exitPointerLock' in window.document;\n}\n\nfunction supportsGestureEvents() {\n  try {\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\n\nconst SUPPORT = {\n  isBrowser,\n  gesture: supportsGestureEvents(),\n  touch: isTouchScreen(),\n  touchscreen: isTouchScreen(),\n  pointer: supportsPointerEvents(),\n  pointerLock: supportsPointerLock()\n};\n\nconst DEFAULT_PREVENT_SCROLL_DELAY = 250;\nconst DEFAULT_DRAG_DELAY = 180;\nconst DEFAULT_SWIPE_VELOCITY = 0.5;\nconst DEFAULT_SWIPE_DISTANCE = 50;\nconst DEFAULT_SWIPE_DURATION = 250;\nconst DEFAULT_DRAG_AXIS_THRESHOLD = {\n  mouse: 0,\n  touch: 0,\n  pen: 8\n};\nconst dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  device(_v, _k, {\n    pointer: {\n      touch = false,\n      lock = false,\n      mouse = false\n    } = {}\n  }) {\n    this.pointerLock = lock && SUPPORT.pointerLock;\n    if (SUPPORT.touch && touch) return 'touch';\n    if (this.pointerLock) return 'mouse';\n    if (SUPPORT.pointer && !mouse) return 'pointer';\n    if (SUPPORT.touch) return 'touch';\n    return 'mouse';\n  },\n\n  preventScrollAxis(value, _k, {\n    preventScroll\n  }) {\n    this.preventScrollDelay = typeof preventScroll === 'number' ? preventScroll : preventScroll || preventScroll === undefined && value ? DEFAULT_PREVENT_SCROLL_DELAY : undefined;\n    if (!SUPPORT.touchscreen || preventScroll === false) return undefined;\n    return value ? value : preventScroll !== undefined ? 'y' : undefined;\n  },\n\n  pointerCapture(_v, _k, {\n    pointer: {\n      capture = true,\n      buttons = 1\n    } = {}\n  }) {\n    this.pointerButtons = buttons;\n    return !this.pointerLock && this.device === 'pointer' && capture;\n  },\n\n  threshold(value, _k, {\n    filterTaps = false,\n    tapsThreshold = 3,\n    axis = undefined\n  }) {\n    const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);\n    this.filterTaps = filterTaps;\n    this.tapsThreshold = tapsThreshold;\n    return threshold;\n  },\n\n  swipe({\n    velocity = DEFAULT_SWIPE_VELOCITY,\n    distance = DEFAULT_SWIPE_DISTANCE,\n    duration = DEFAULT_SWIPE_DURATION\n  } = {}) {\n    return {\n      velocity: this.transform(V.toVector(velocity)),\n      distance: this.transform(V.toVector(distance)),\n      duration\n    };\n  },\n\n  delay(value = 0) {\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY;\n\n      case false:\n        return 0;\n\n      default:\n        return value;\n    }\n  },\n\n  axisThreshold(value) {\n    if (!value) return DEFAULT_DRAG_AXIS_THRESHOLD;\n    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);\n  }\n\n});\n\nif (process.env.NODE_ENV === 'development') {\n  Object.assign(dragConfigResolver, {\n    useTouch(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`useTouch\\` option has been renamed to \\`pointer.touch\\`. Use it as in \\`{ pointer: { touch: true } }\\`.`);\n      }\n\n      return NaN;\n    },\n\n    experimental_preventWindowScrollY(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`experimental_preventWindowScrollY\\` option has been renamed to \\`preventScroll\\`.`);\n      }\n\n      return NaN;\n    },\n\n    swipeVelocity(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeVelocity\\` option has been renamed to \\`swipe.velocity\\`. Use it as in \\`{ swipe: { velocity: 0.5 } }\\`.`);\n      }\n\n      return NaN;\n    },\n\n    swipeDistance(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeDistance\\` option has been renamed to \\`swipe.distance\\`. Use it as in \\`{ swipe: { distance: 50 } }\\`.`);\n      }\n\n      return NaN;\n    },\n\n    swipeDuration(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeDuration\\` option has been renamed to \\`swipe.duration\\`. Use it as in \\`{ swipe: { duration: 250 } }\\`.`);\n      }\n\n      return NaN;\n    }\n\n  });\n}\n\nconst SCALE_ANGLE_RATIO_INTENT_DEG = 30;\nconst PINCH_WHEEL_RATIO = 100;\nclass PinchEngine extends Engine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'pinching');\n\n    _defineProperty(this, \"aliasKey\", 'da');\n  }\n\n  init() {\n    this.state.offset = [1, 0];\n    this.state.lastOffset = [1, 0];\n    this.state._pointerEvents = new Map();\n  }\n\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._touchIds = [];\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n    state.turns = 0;\n  }\n\n  computeOffset() {\n    const {\n      type,\n      movement,\n      lastOffset\n    } = this.state;\n\n    if (type === 'wheel') {\n      this.state.offset = V.add(movement, lastOffset);\n    } else {\n      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];\n    }\n  }\n\n  computeMovement() {\n    const {\n      offset,\n      lastOffset\n    } = this.state;\n    this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];\n  }\n\n  axisIntent() {\n    const state = this.state;\n    const [_m0, _m1] = state._movement;\n\n    if (!state.axis) {\n      const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);\n      if (axisMovementDifference < 0) state.axis = 'angle';else if (axisMovementDifference > 0) state.axis = 'scale';\n    }\n  }\n\n  restrictToAxis(v) {\n    if (this.config.lockDirection) {\n      if (this.state.axis === 'scale') v[1] = 0;else if (this.state.axis === 'angle') v[0] = 0;\n    }\n  }\n\n  cancel() {\n    const state = this.state;\n    if (state.canceled) return;\n    setTimeout(() => {\n      state.canceled = true;\n      state._active = false;\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n\n  touchStart(event) {\n    this.ctrl.setEventIds(event);\n    const state = this.state;\n    const ctrlTouchIds = this.ctrl.touchIds;\n\n    if (state._active) {\n      if (state._touchIds.every(id => ctrlTouchIds.has(id))) return;\n    }\n\n    if (ctrlTouchIds.size < 2) return;\n    this.start(event);\n    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);\n    const payload = touchDistanceAngle(event, state._touchIds);\n    this.pinchStart(event, payload);\n  }\n\n  pointerStart(event) {\n    if (event.buttons != null && event.buttons % 2 !== 1) return;\n    this.ctrl.setEventIds(event);\n    event.target.setPointerCapture(event.pointerId);\n    const state = this.state;\n    const _pointerEvents = state._pointerEvents;\n    const ctrlPointerIds = this.ctrl.pointerIds;\n\n    if (state._active) {\n      if (Array.from(_pointerEvents.keys()).every(id => ctrlPointerIds.has(id))) return;\n    }\n\n    if (_pointerEvents.size < 2) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n\n    if (state._pointerEvents.size < 2) return;\n    this.start(event);\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    this.pinchStart(event, payload);\n  }\n\n  pinchStart(event, payload) {\n    const state = this.state;\n    state.origin = payload.origin;\n    this.computeValues([payload.distance, payload.angle]);\n    this.computeInitial();\n    this.compute(event);\n    this.emit();\n  }\n\n  touchMove(event) {\n    if (!this.state._active) return;\n    const payload = touchDistanceAngle(event, this.state._touchIds);\n    this.pinchMove(event, payload);\n  }\n\n  pointerMove(event) {\n    const _pointerEvents = this.state._pointerEvents;\n\n    if (_pointerEvents.has(event.pointerId)) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n\n    if (!this.state._active) return;\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    this.pinchMove(event, payload);\n  }\n\n  pinchMove(event, payload) {\n    const state = this.state;\n    const prev_a = state._values[1];\n    const delta_a = payload.angle - prev_a;\n    let delta_turns = 0;\n    if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);\n    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);\n    state.origin = payload.origin;\n    state.turns = delta_turns;\n    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];\n    this.compute(event);\n    this.emit();\n  }\n\n  touchEnd(event) {\n    this.ctrl.setEventIds(event);\n    if (!this.state._active) return;\n\n    if (this.state._touchIds.some(id => !this.ctrl.touchIds.has(id))) {\n      this.state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n\n  pointerEnd(event) {\n    const state = this.state;\n    this.ctrl.setEventIds(event);\n\n    try {\n      event.target.releasePointerCapture(event.pointerId);\n    } catch (_unused) {}\n\n    if (state._pointerEvents.has(event.pointerId)) {\n      state._pointerEvents.delete(event.pointerId);\n    }\n\n    if (!state._active) return;\n\n    if (state._pointerEvents.size < 2) {\n      state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n\n  gestureStart(event) {\n    if (event.cancelable) event.preventDefault();\n    const state = this.state;\n    if (state._active) return;\n    this.start(event);\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n\n  gestureMove(event) {\n    if (event.cancelable) event.preventDefault();\n    if (!this.state._active) return;\n    const state = this.state;\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    const _previousMovement = state._movement;\n    state._movement = [event.scale - 1, event.rotation];\n    state._delta = V.sub(state._movement, _previousMovement);\n    this.compute(event);\n    this.emit();\n  }\n\n  gestureEnd(event) {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n\n  wheel(event) {\n    const modifierKey = this.config.modifierKey;\n    if (modifierKey && !event[modifierKey]) return;\n    if (!this.state._active) this.wheelStart(event);else this.wheelChange(event);\n    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n  }\n\n  wheelStart(event) {\n    this.start(event);\n    this.wheelChange(event);\n  }\n\n  wheelChange(event) {\n    const isR3f = ('uv' in event);\n\n    if (!isR3f) {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n\n      if (process.env.NODE_ENV === 'development' && !event.defaultPrevented) {\n        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \\`target\\` option.\\n\\nThis message will only appear in development mode.`);\n      }\n    }\n\n    const state = this.state;\n    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];\n    V.addTo(state._movement, state._delta);\n    this.state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n\n  wheelEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    const device = this.config.device;\n\n    if (!!device) {\n      bindFunction(device, 'start', this[device + 'Start'].bind(this));\n      bindFunction(device, 'change', this[device + 'Move'].bind(this));\n      bindFunction(device, 'end', this[device + 'End'].bind(this));\n      bindFunction(device, 'cancel', this[device + 'End'].bind(this));\n    } else {\n      bindFunction('wheel', '', this.wheel.bind(this), {\n        passive: false\n      });\n    }\n  }\n\n}\n\nconst pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  device(_v, _k, {\n    shared,\n    pointer: {\n      touch = false\n    } = {}\n  }) {\n    const sharedConfig = shared;\n    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return 'gesture';\n    if (SUPPORT.touch && touch) return 'touch';\n\n    if (SUPPORT.touchscreen) {\n      if (SUPPORT.pointer) return 'pointer';\n      if (SUPPORT.touch) return 'touch';\n    }\n  },\n\n  bounds(_v, _k, {\n    scaleBounds = {},\n    angleBounds = {}\n  }) {\n    const _scaleBounds = state => {\n      const D = assignDefault(call(scaleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [D.min, D.max];\n    };\n\n    const _angleBounds = state => {\n      const A = assignDefault(call(angleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [A.min, A.max];\n    };\n\n    if (typeof scaleBounds !== 'function' && typeof angleBounds !== 'function') return [_scaleBounds(), _angleBounds()];\n    return state => [_scaleBounds(state), _angleBounds(state)];\n  },\n\n  threshold(value, _k, config) {\n    this.lockDirection = config.axis === 'lock';\n    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);\n    return threshold;\n  },\n\n  modifierKey(value) {\n    if (value === undefined) return 'ctrlKey';\n    return value;\n  }\n\n});\n\nclass MoveEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'moving');\n  }\n\n  move(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    if (!this.state._active) this.moveStart(event);else this.moveChange(event);\n    this.timeoutStore.add('moveEnd', this.moveEnd.bind(this));\n  }\n\n  moveStart(event) {\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.computeInitial();\n    this.emit();\n  }\n\n  moveChange(event) {\n    if (!this.state._active) return;\n    const values = pointerValues(event);\n    const state = this.state;\n    state._delta = V.sub(values, state._values);\n    V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n\n  moveEnd(event) {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('pointer', 'change', this.move.bind(this));\n    bindFunction('pointer', 'leave', this.moveEnd.bind(this));\n  }\n\n}\n\nconst moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\n\nclass ScrollEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'scrolling');\n  }\n\n  scroll(event) {\n    if (!this.state._active) this.start(event);\n    this.scrollChange(event);\n    this.timeoutStore.add('scrollEnd', this.scrollEnd.bind(this));\n  }\n\n  scrollChange(event) {\n    if (event.cancelable) event.preventDefault();\n    const state = this.state;\n    const values = scrollValues(event);\n    state._delta = V.sub(values, state._values);\n    V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n\n  scrollEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('scroll', '', this.scroll.bind(this));\n  }\n\n}\n\nconst scrollConfigResolver = coordinatesConfigResolver;\n\nclass WheelEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'wheeling');\n  }\n\n  wheel(event) {\n    if (!this.state._active) this.start(event);\n    this.wheelChange(event);\n    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n  }\n\n  wheelChange(event) {\n    const state = this.state;\n    state._delta = wheelValues(event);\n    V.addTo(state._movement, state._delta);\n    const [ox, oy] = state.overflow;\n    const [dx, dy] = state._delta;\n    const [dirx, diry] = state._direction;\n\n    if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {\n      state._movement[0] = state._movementBound[0];\n    }\n\n    if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {\n      state._movement[1] = state._movementBound[1];\n    }\n\n    this.compute(event);\n    this.emit();\n  }\n\n  wheelEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('wheel', '', this.wheel.bind(this));\n  }\n\n}\n\nconst wheelConfigResolver = coordinatesConfigResolver;\n\nclass HoverEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"ingKey\", 'hovering');\n  }\n\n  enter(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.emit();\n  }\n\n  leave(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    const state = this.state;\n    if (!state._active) return;\n    state._active = false;\n    const values = pointerValues(event);\n    state._movement = state._delta = V.sub(values, state._values);\n    this.computeValues(values);\n    this.compute(event);\n    state.delta = state.movement;\n    this.emit();\n  }\n\n  bind(bindFunction) {\n    bindFunction('pointer', 'enter', this.enter.bind(this));\n    bindFunction('pointer', 'leave', this.leave.bind(this));\n  }\n\n}\n\nconst hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\n\nconst EngineMap = new Map();\nconst ConfigResolverMap = new Map();\nfunction registerAction(action) {\n  EngineMap.set(action.key, action.engine);\n  ConfigResolverMap.set(action.key, action.resolver);\n}\nconst dragAction = {\n  key: 'drag',\n  engine: DragEngine,\n  resolver: dragConfigResolver\n};\nconst hoverAction = {\n  key: 'hover',\n  engine: HoverEngine,\n  resolver: hoverConfigResolver\n};\nconst moveAction = {\n  key: 'move',\n  engine: MoveEngine,\n  resolver: moveConfigResolver\n};\nconst pinchAction = {\n  key: 'pinch',\n  engine: PinchEngine,\n  resolver: pinchConfigResolver\n};\nconst scrollAction = {\n  key: 'scroll',\n  engine: ScrollEngine,\n  resolver: scrollConfigResolver\n};\nconst wheelAction = {\n  key: 'wheel',\n  engine: WheelEngine,\n  resolver: wheelConfigResolver\n};\n\nexport { ConfigResolverMap as C, EngineMap as E, SUPPORT as S, _objectSpread2 as _, _defineProperty as a, touchIds as b, chain as c, toHandlerProp as d, dragAction as e, pinchAction as f, hoverAction as h, isTouch as i, moveAction as m, parseProp as p, registerAction as r, scrollAction as s, toDomEventType as t, wheelAction as w };\n","import { S as SUPPORT, C as ConfigResolverMap, _ as _objectSpread2, a as _defineProperty, t as toDomEventType, i as isTouch, b as touchIds, E as EngineMap, c as chain, p as parseProp, d as toHandlerProp } from './actions-8e12537b.esm.js';\nimport './maths-b2a210f4.esm.js';\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nconst sharedConfigResolver = {\n  target(value) {\n    if (value) {\n      return () => 'current' in value ? value.current : value;\n    }\n\n    return undefined;\n  },\n\n  enabled(value = true) {\n    return value;\n  },\n\n  window(value = SUPPORT.isBrowser ? window : undefined) {\n    return value;\n  },\n\n  eventOptions({\n    passive = true,\n    capture = false\n  } = {}) {\n    return {\n      passive,\n      capture\n    };\n  },\n\n  transform(value) {\n    return value;\n  }\n\n};\n\nconst _excluded = [\"target\", \"eventOptions\", \"window\", \"enabled\", \"transform\"];\nfunction resolveWith(config = {}, resolvers) {\n  const result = {};\n\n  for (const [key, resolver] of Object.entries(resolvers)) {\n    switch (typeof resolver) {\n      case 'function':\n        if (process.env.NODE_ENV === 'development') {\n          const r = resolver.call(result, config[key], key, config);\n          if (!Number.isNaN(r)) result[key] = r;\n        } else {\n          result[key] = resolver.call(result, config[key], key, config);\n        }\n\n        break;\n\n      case 'object':\n        result[key] = resolveWith(config[key], resolver);\n        break;\n\n      case 'boolean':\n        if (resolver) result[key] = config[key];\n        break;\n    }\n  }\n\n  return result;\n}\nfunction parse(config, gestureKey) {\n  const _ref = config,\n        {\n    target,\n    eventOptions,\n    window,\n    enabled,\n    transform\n  } = _ref,\n        rest = _objectWithoutProperties(_ref, _excluded);\n\n  const _config = {\n    shared: resolveWith({\n      target,\n      eventOptions,\n      window,\n      enabled,\n      transform\n    }, sharedConfigResolver)\n  };\n\n  if (gestureKey) {\n    const resolver = ConfigResolverMap.get(gestureKey);\n    _config[gestureKey] = resolveWith(_objectSpread2({\n      shared: _config.shared\n    }, rest), resolver);\n  } else {\n    for (const key in rest) {\n      const resolver = ConfigResolverMap.get(key);\n\n      if (resolver) {\n        _config[key] = resolveWith(_objectSpread2({\n          shared: _config.shared\n        }, rest[key]), resolver);\n      } else if (process.env.NODE_ENV === 'development') {\n        if (!['drag', 'pinch', 'scroll', 'wheel', 'move', 'hover'].includes(key)) {\n          if (key === 'domTarget') {\n            throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n          }\n\n          console.warn(`[@use-gesture]: Unknown config key \\`${key}\\` was used. Please read the documentation for further information.`);\n        }\n      }\n    }\n  }\n\n  return _config;\n}\n\nclass EventStore {\n  constructor(ctrl) {\n    _defineProperty(this, \"_listeners\", []);\n\n    this._ctrl = ctrl;\n  }\n\n  add(element, device, action, handler, options) {\n    const type = toDomEventType(device, action);\n\n    const eventOptions = _objectSpread2(_objectSpread2({}, this._ctrl.config.shared.eventOptions), options);\n\n    element.addEventListener(type, handler, eventOptions);\n\n    this._listeners.push(() => element.removeEventListener(type, handler, eventOptions));\n  }\n\n  clean() {\n    this._listeners.forEach(remove => remove());\n\n    this._listeners = [];\n  }\n\n}\n\nclass TimeoutStore {\n  constructor() {\n    _defineProperty(this, \"_timeouts\", new Map());\n  }\n\n  add(key, callback, ms = 140, ...args) {\n    this.remove(key);\n\n    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));\n  }\n\n  remove(key) {\n    const timeout = this._timeouts.get(key);\n\n    if (timeout) window.clearTimeout(timeout);\n  }\n\n  clean() {\n    this._timeouts.forEach(timeout => void window.clearTimeout(timeout));\n\n    this._timeouts.clear();\n  }\n\n}\n\nclass Controller {\n  constructor(handlers) {\n    _defineProperty(this, \"gestures\", new Set());\n\n    _defineProperty(this, \"_targetEventStore\", new EventStore(this));\n\n    _defineProperty(this, \"gestureEventStores\", {});\n\n    _defineProperty(this, \"gestureTimeoutStores\", {});\n\n    _defineProperty(this, \"handlers\", {});\n\n    _defineProperty(this, \"config\", {});\n\n    _defineProperty(this, \"pointerIds\", new Set());\n\n    _defineProperty(this, \"touchIds\", new Set());\n\n    _defineProperty(this, \"state\", {\n      shared: {\n        shiftKey: false,\n        metaKey: false,\n        ctrlKey: false,\n        altKey: false\n      }\n    });\n\n    resolveGestures(this, handlers);\n  }\n\n  setEventIds(event) {\n    if (isTouch(event)) {\n      this.touchIds = new Set(touchIds(event));\n    } else if ('pointerId' in event) {\n      if (event.type === 'pointerup' || event.type === 'pointercancel') this.pointerIds.delete(event.pointerId);else if (event.type === 'pointerdown') this.pointerIds.add(event.pointerId);\n    }\n  }\n\n  applyHandlers(handlers, nativeHandlers) {\n    this.handlers = handlers;\n    this.nativeHandlers = nativeHandlers;\n  }\n\n  applyConfig(config, gestureKey) {\n    this.config = parse(config, gestureKey);\n  }\n\n  clean() {\n    this._targetEventStore.clean();\n\n    for (const key of this.gestures) {\n      this.gestureEventStores[key].clean();\n      this.gestureTimeoutStores[key].clean();\n    }\n  }\n\n  effect() {\n    if (this.config.shared.target) this.bind();\n    return () => this._targetEventStore.clean();\n  }\n\n  bind(...args) {\n    const sharedConfig = this.config.shared;\n    const eventOptions = sharedConfig.eventOptions;\n    const props = {};\n    let target;\n\n    if (sharedConfig.target) {\n      target = sharedConfig.target();\n      if (!target) return;\n    }\n\n    const bindFunction = bindToProps(props, eventOptions, !!target);\n\n    if (sharedConfig.enabled) {\n      for (const gestureKey of this.gestures) {\n        if (this.config[gestureKey].enabled) {\n          const Engine = EngineMap.get(gestureKey);\n          new Engine(this, args, gestureKey).bind(bindFunction);\n        }\n      }\n\n      for (const eventKey in this.nativeHandlers) {\n        bindFunction(eventKey, '', event => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {\n          event,\n          args\n        })), undefined, true);\n      }\n    }\n\n    for (const handlerProp in props) {\n      props[handlerProp] = chain(...props[handlerProp]);\n    }\n\n    if (!target) return props;\n\n    for (const handlerProp in props) {\n      const {\n        device,\n        capture,\n        passive\n      } = parseProp(handlerProp);\n\n      this._targetEventStore.add(target, device, '', props[handlerProp], {\n        capture,\n        passive\n      });\n    }\n  }\n\n}\n\nfunction setupGesture(ctrl, gestureKey) {\n  ctrl.gestures.add(gestureKey);\n  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl);\n  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();\n}\n\nfunction resolveGestures(ctrl, internalHandlers) {\n  if (internalHandlers.drag) setupGesture(ctrl, 'drag');\n  if (internalHandlers.wheel) setupGesture(ctrl, 'wheel');\n  if (internalHandlers.scroll) setupGesture(ctrl, 'scroll');\n  if (internalHandlers.move) setupGesture(ctrl, 'move');\n  if (internalHandlers.pinch) setupGesture(ctrl, 'pinch');\n  if (internalHandlers.hover) setupGesture(ctrl, 'hover');\n}\n\nconst bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {\n  var _options$capture, _options$passive;\n\n  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;\n  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;\n  let handlerProp = isNative ? device : toHandlerProp(device, action, capture);\n  if (withPassiveOption && passive) handlerProp += 'Passive';\n  props[handlerProp] = props[handlerProp] || [];\n  props[handlerProp].push(handler);\n};\n\nconst RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;\n\nfunction sortHandlers(_handlers) {\n  const native = {};\n  const handlers = {};\n  const actions = new Set();\n\n  for (let key in _handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch);\n      handlers[key] = _handlers[key];\n    } else {\n      native[key] = _handlers[key];\n    }\n  }\n\n  return [handlers, native, actions];\n}\n\nfunction registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {\n  if (!actions.has(handlerKey)) return;\n\n  if (!EngineMap.has(key)) {\n    if (process.env.NODE_ENV === 'development') {\n      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \\`${key}\\` gesture but isn't properly configured.\\n\\nPlease add \\`${key}Action\\` when creating your handler.`);\n    }\n\n    return;\n  }\n\n  const startKey = handlerKey + 'Start';\n  const endKey = handlerKey + 'End';\n\n  const fn = state => {\n    let memo = undefined;\n    if (state.first && startKey in handlers) handlers[startKey](state);\n    if (handlerKey in handlers) memo = handlers[handlerKey](state);\n    if (state.last && endKey in handlers) handlers[endKey](state);\n    return memo;\n  };\n\n  internalHandlers[key] = fn;\n  config[key] = config[key] || {};\n}\n\nfunction parseMergedHandlers(mergedHandlers, mergedConfig) {\n  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);\n  const internalHandlers = {};\n  registerGesture(actions, handlers, 'onDrag', 'drag', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onWheel', 'wheel', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onScroll', 'scroll', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onPinch', 'pinch', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onMove', 'move', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onHover', 'hover', internalHandlers, mergedConfig);\n  return {\n    handlers: internalHandlers,\n    config: mergedConfig,\n    nativeHandlers\n  };\n}\n\nexport { Controller, parseMergedHandlers };\n","import { registerAction, dragAction, pinchAction, wheelAction, scrollAction, moveAction, hoverAction } from '@use-gesture/core/actions';\nexport * from '@use-gesture/core/actions';\nimport React from 'react';\nimport { Controller, parseMergedHandlers } from '@use-gesture/core';\nexport * from '@use-gesture/core/utils';\nexport * from '@use-gesture/core/types';\n\nfunction useRecognizers(handlers, config = {}, gestureKey, nativeHandlers) {\n  const ctrl = React.useMemo(() => new Controller(handlers), []);\n  ctrl.applyHandlers(handlers, nativeHandlers);\n  ctrl.applyConfig(config, gestureKey);\n  React.useEffect(ctrl.effect.bind(ctrl));\n  React.useEffect(() => {\n    return ctrl.clean.bind(ctrl);\n  }, []);\n\n  if (config.target === undefined) {\n    return ctrl.bind.bind(ctrl);\n  }\n\n  return undefined;\n}\n\nfunction useDrag(handler, config) {\n  registerAction(dragAction);\n  return useRecognizers({\n    drag: handler\n  }, config || {}, 'drag');\n}\n\nfunction usePinch(handler, config) {\n  registerAction(pinchAction);\n  return useRecognizers({\n    pinch: handler\n  }, config || {}, 'pinch');\n}\n\nfunction useWheel(handler, config) {\n  registerAction(wheelAction);\n  return useRecognizers({\n    wheel: handler\n  }, config || {}, 'wheel');\n}\n\nfunction useScroll(handler, config) {\n  registerAction(scrollAction);\n  return useRecognizers({\n    scroll: handler\n  }, config || {}, 'scroll');\n}\n\nfunction useMove(handler, config) {\n  registerAction(moveAction);\n  return useRecognizers({\n    move: handler\n  }, config || {}, 'move');\n}\n\nfunction useHover(handler, config) {\n  registerAction(hoverAction);\n  return useRecognizers({\n    hover: handler\n  }, config || {}, 'hover');\n}\n\nfunction createUseGesture(actions) {\n  actions.forEach(registerAction);\n  return function useGesture(_handlers, _config) {\n    const {\n      handlers,\n      nativeHandlers,\n      config\n    } = parseMergedHandlers(_handlers, _config || {});\n    return useRecognizers(handlers, config, undefined, nativeHandlers);\n  };\n}\n\nfunction useGesture(handlers, config) {\n  const hook = createUseGesture([dragAction, pinchAction, scrollAction, wheelAction, moveAction, hoverAction]);\n  return hook(handlers, config || {});\n}\n\nexport { createUseGesture, useDrag, useGesture, useHover, useMove, usePinch, useScroll, useWheel };\n"],"names":["clamp","v","min","max","Math","V","fallback","undefined","Array","isArray","v1","v2","rubberband","distance","dimension","constant","abs","Infinity","pow","rubberbandIfOutOfBounds","position","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","getOwnPropertyDescriptors","defineProperties","EVENT_TYPE_MAP","pointer","start","change","end","mouse","touch","gesture","capitalize","string","toUpperCase","slice","toHandlerProp","device","action","capture","deviceProps","actionKey","pointerCaptureEvents","parseProp","prop","eventKey","substring","toLowerCase","passive","indexOf","replace","captureKey","includes","isTouch","event","getPointerType","pointerType","getValueEvent","type","changedTouches","targetTouches","getTouchList","touchIds","from","touches","e","_event$currentTarget","_event$currentTarget$","currentTarget","contains","call","getCurrentTargetTouchList","map","identifier","pointerId","valueEvent","pointerValues","clientX","clientY","args","noop","chain","fns","result","fn","this","assignDefault","assign","Engine","ctrl","state","computeValues","computeInitial","init","reset","shared","gestureEventStores","gestureTimeoutStores","config","handlers","ingKey","_active","active","_blocked","_force","_step","intentional","_movement","_distance","_direction","_delta","_bounds","axis","memo","elapsedTime","direction","overflow","_movementBound","velocity","movement","delta","timeStamp","lastOffset","offset","startTime","values","_values","transform","_initial","initial","dt","preventDefault","cancelable","pointerIds","size","locked","document","pointerLockElement","payload","buttons","shiftKey","altKey","metaKey","ctrlKey","getEventDetails","down","pressed","_absoluteDelta","axisIntent","_m0","_m1","threshold","t0","t1","hasCustomTransform","sign","v0","restrictToAxis","previousOffset","gestureIsActive","first","last","bounds","setup","computeOffset","ox","oy","x0","x1","y0","y1","Vx","Vy","Rx","Ry","X0","X1","Y0","Y1","computeRubberband","computeMovement","absoluteDelta","clean","triggerAllEvents","handler","aliasKey","eventStore","timeoutStore","CoordinatesEngine","axisThreshold","dx","dy","absDx","absDy","selectAxis","lockDirection","identity","DEFAULT_RUBBERBAND","commonConfigResolver","enabled","_k","coordinatesConfigResolver","_v","current","HTMLElement","left","right","top","bottom","DISPLACEMENT","KEYS_DELTA_MAP","ArrowRight","factor","ArrowLeft","ArrowUp","ArrowDown","DragEngine","_pointerId","_pointerActive","_keyboardActive","_preventScroll","_delayed","swipe","tap","canceled","cancel","bind","boundRect","getBoundingClientRect","targetRect","setTimeout","compute","emit","pointerClean","pointerButtons","setEventIds","pointerCapture","setPointerCapture","setupPointer","preventScrollAxis","setupScrollPrevention","delay","setupDelayTrigger","startPointerDrag","id","movementX","movementY","remove","hasPointerCapture","releasePointerCapture","_unused","process","setActive","tapsThreshold","filterTaps","dirx","diry","vx","vy","mx","my","svx","svy","sx","sy","sdt","duration","stopPropagation","pointerLock","requestPointerLock","add","sharedConfig","window","pointerMove","pointerUp","exitPointerLock","persist","persistEvent","preventScroll","preventScrollDelay","deltaFn","bindFunction","pointerDown","keyDown","keyUp","pointerClick","isBrowser","createElement","isTouchScreen","navigator","maxTouchPoints","SUPPORT","GestureEvent","supportsGestureEvents","touchscreen","DEFAULT_DRAG_AXIS_THRESHOLD","pen","dragConfigResolver","lock","scaleBounds","angleBounds","_scaleBounds","D","_angleBounds","A","modifierKey","mouseOnly","EngineMap","Map","ConfigResolverMap","dragAction","engine","resolver","_objectWithoutProperties","excluded","sourceKeys","_objectWithoutPropertiesLoose","sourceSymbolKeys","prototype","propertyIsEnumerable","sharedConfigResolver","eventOptions","_excluded","resolveWith","resolvers","entries","EventStore","_ctrl","element","options","toDomEventType","addEventListener","_listeners","removeEventListener","TimeoutStore","callback","ms","_timeouts","set","timeout","get","clearTimeout","clear","Controller","Set","internalHandlers","drag","setupGesture","wheel","scroll","move","pinch","hover","resolveGestures","delete","nativeHandlers","gestureKey","_ref","rest","_config","parse","_targetEventStore","gestures","props","bindToProps","handlerProp","withPassiveOption","_options$capture","_options$passive","isNative","useRecognizers","React","applyHandlers","applyConfig","effect","useDrag"],"sourceRoot":""}