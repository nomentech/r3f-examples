{"version":3,"file":"static/js/290.10c49bf9.chunk.js","mappings":"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","sources":["../node_modules/three-stdlib/deprecated/Geometry.js","basic-examples/physics-with-convex-polyhedrons/Example.tsx"],"sourcesContent":["import { Matrix4, Object3D, Vector3, EventDispatcher, MathUtils, Matrix3, Color, Box3, Sphere, BufferGeometry, BufferAttribute, Float32BufferAttribute, Vector2 } from 'three';\n\nconst _m1 = new Matrix4();\n\nconst _obj = new Object3D();\n\nconst _offset = new Vector3();\n\nclass Geometry extends EventDispatcher {\n  constructor() {\n    super();\n    this.isGeometry = true;\n    this.uuid = MathUtils.generateUUID();\n    this.name = '';\n    this.type = 'Geometry';\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // update flags\n\n    this.elementsNeedUpdate = false;\n    this.verticesNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.lineDistancesNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n\n  applyMatrix4(matrix) {\n    const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const vertex = this.vertices[i];\n      vertex.applyMatrix4(matrix);\n    }\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.normal.applyMatrix3(normalMatrix).normalize();\n\n      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n      }\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    this.verticesNeedUpdate = true;\n    this.normalsNeedUpdate = true;\n    return this;\n  }\n\n  rotateX(angle) {\n    // rotate geometry around world x-axis\n    _m1.makeRotationX(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  rotateY(angle) {\n    // rotate geometry around world y-axis\n    _m1.makeRotationY(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  rotateZ(angle) {\n    // rotate geometry around world z-axis\n    _m1.makeRotationZ(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  translate(x, y, z) {\n    // translate geometry\n    _m1.makeTranslation(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  scale(x, y, z) {\n    // scale geometry\n    _m1.makeScale(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  lookAt(vector) {\n    _obj.lookAt(vector);\n\n    _obj.updateMatrix();\n\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  }\n\n  fromBufferGeometry(geometry) {\n    const scope = this;\n    const index = geometry.index !== null ? geometry.index : undefined;\n    const attributes = geometry.attributes;\n\n    if (attributes.position === undefined) {\n      console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');\n      return this;\n    }\n\n    const position = attributes.position;\n    const normal = attributes.normal;\n    const color = attributes.color;\n    const uv = attributes.uv;\n    const uv2 = attributes.uv2;\n    if (uv2 !== undefined) this.faceVertexUvs[1] = [];\n\n    for (let i = 0; i < position.count; i++) {\n      scope.vertices.push(new Vector3().fromBufferAttribute(position, i));\n\n      if (color !== undefined) {\n        scope.colors.push(new Color().fromBufferAttribute(color, i));\n      }\n    }\n\n    function addFace(a, b, c, materialIndex) {\n      const vertexColors = color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n      const vertexNormals = normal === undefined ? [] : [new Vector3().fromBufferAttribute(normal, a), new Vector3().fromBufferAttribute(normal, b), new Vector3().fromBufferAttribute(normal, c)];\n      const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n      scope.faces.push(face);\n\n      if (uv !== undefined) {\n        scope.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv, a), new Vector2().fromBufferAttribute(uv, b), new Vector2().fromBufferAttribute(uv, c)]);\n      }\n\n      if (uv2 !== undefined) {\n        scope.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv2, a), new Vector2().fromBufferAttribute(uv2, b), new Vector2().fromBufferAttribute(uv2, c)]);\n      }\n    }\n\n    const groups = geometry.groups;\n\n    if (groups.length > 0) {\n      for (let i = 0; i < groups.length; i++) {\n        const group = groups[i];\n        const start = group.start;\n        const count = group.count;\n\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          if (index !== undefined) {\n            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n          } else {\n            addFace(j, j + 1, j + 2, group.materialIndex);\n          }\n        }\n      }\n    } else {\n      if (index !== undefined) {\n        for (let i = 0; i < index.count; i += 3) {\n          addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));\n        }\n      } else {\n        for (let i = 0; i < position.count; i += 3) {\n          addFace(i, i + 1, i + 2);\n        }\n      }\n    }\n\n    this.computeFaceNormals();\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    return this;\n  }\n\n  center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  }\n\n  normalize() {\n    this.computeBoundingSphere();\n    const center = this.boundingSphere.center;\n    const radius = this.boundingSphere.radius;\n    const s = radius === 0 ? 1 : 1.0 / radius;\n    const matrix = new Matrix4();\n    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n    this.applyMatrix4(matrix);\n    return this;\n  }\n\n  computeFaceNormals() {\n    const cb = new Vector3(),\n          ab = new Vector3();\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vA = this.vertices[face.a];\n      const vB = this.vertices[face.b];\n      const vC = this.vertices[face.c];\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab);\n      cb.normalize();\n      face.normal.copy(cb);\n    }\n  }\n\n  computeVertexNormals(areaWeighted = true) {\n    const vertices = new Array(this.vertices.length);\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v] = new Vector3();\n    }\n\n    if (areaWeighted) {\n      // vertex normals weighted by triangle areas\n      // http://www.iquilezles.org/www/articles/normals/normals.htm\n      const cb = new Vector3(),\n            ab = new Vector3();\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const vA = this.vertices[face.a];\n        const vB = this.vertices[face.b];\n        const vC = this.vertices[face.c];\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        vertices[face.a].add(cb);\n        vertices[face.b].add(cb);\n        vertices[face.c].add(cb);\n      }\n    } else {\n      this.computeFaceNormals();\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        vertices[face.a].add(face.normal);\n        vertices[face.b].add(face.normal);\n        vertices[face.c].add(face.normal);\n      }\n    }\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v].normalize();\n    }\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(vertices[face.a]);\n        vertexNormals[1].copy(vertices[face.b]);\n        vertexNormals[2].copy(vertices[face.c]);\n      } else {\n        vertexNormals[0] = vertices[face.a].clone();\n        vertexNormals[1] = vertices[face.b].clone();\n        vertexNormals[2] = vertices[face.c].clone();\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n\n  computeFlatVertexNormals() {\n    this.computeFaceNormals();\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(face.normal);\n        vertexNormals[1].copy(face.normal);\n        vertexNormals[2].copy(face.normal);\n      } else {\n        vertexNormals[0] = face.normal.clone();\n        vertexNormals[1] = face.normal.clone();\n        vertexNormals[2] = face.normal.clone();\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true;\n    }\n  }\n\n  computeMorphNormals() {\n    // save original normals\n    // - create temp variables on first access\n    //   otherwise just copy (for faster repeated calls)\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n\n      if (!face.__originalFaceNormal) {\n        face.__originalFaceNormal = face.normal.clone();\n      } else {\n        face.__originalFaceNormal.copy(face.normal);\n      }\n\n      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\n\n      for (let i = 0, il = face.vertexNormals.length; i < il; i++) {\n        if (!face.__originalVertexNormals[i]) {\n          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n        } else {\n          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n        }\n      }\n    } // use temp geometry to compute face and vertex normals for each morph\n\n\n    const tmpGeo = new Geometry();\n    tmpGeo.faces = this.faces;\n\n    for (let i = 0, il = this.morphTargets.length; i < il; i++) {\n      // create on first access\n      if (!this.morphNormals[i]) {\n        this.morphNormals[i] = {};\n        this.morphNormals[i].faceNormals = [];\n        this.morphNormals[i].vertexNormals = [];\n        const dstNormalsFace = this.morphNormals[i].faceNormals;\n        const dstNormalsVertex = this.morphNormals[i].vertexNormals;\n\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n          const faceNormal = new Vector3();\n          const vertexNormals = {\n            a: new Vector3(),\n            b: new Vector3(),\n            c: new Vector3()\n          };\n          dstNormalsFace.push(faceNormal);\n          dstNormalsVertex.push(vertexNormals);\n        }\n      }\n\n      const morphNormals = this.morphNormals[i]; // set vertices to morph target\n\n      tmpGeo.vertices = this.morphTargets[i].vertices; // compute morph normals\n\n      tmpGeo.computeFaceNormals();\n      tmpGeo.computeVertexNormals(); // store morph normals\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f];\n        const faceNormal = morphNormals.faceNormals[f];\n        const vertexNormals = morphNormals.vertexNormals[f];\n        faceNormal.copy(face.normal);\n        vertexNormals.a.copy(face.vertexNormals[0]);\n        vertexNormals.b.copy(face.vertexNormals[1]);\n        vertexNormals.c.copy(face.vertexNormals[2]);\n      }\n    } // restore original normals\n\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f];\n      face.normal = face.__originalFaceNormal;\n      face.vertexNormals = face.__originalVertexNormals;\n    }\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n\n    this.boundingBox.setFromPoints(this.vertices);\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n\n    this.boundingSphere.setFromPoints(this.vertices);\n  }\n\n  merge(geometry, matrix, materialIndexOffset = 0) {\n    if (!(geometry && geometry.isGeometry)) {\n      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);\n      return;\n    }\n\n    let normalMatrix;\n    const vertexOffset = this.vertices.length,\n          vertices1 = this.vertices,\n          vertices2 = geometry.vertices,\n          faces1 = this.faces,\n          faces2 = geometry.faces,\n          colors1 = this.colors,\n          colors2 = geometry.colors;\n\n    if (matrix !== undefined) {\n      normalMatrix = new Matrix3().getNormalMatrix(matrix);\n    } // vertices\n\n\n    for (let i = 0, il = vertices2.length; i < il; i++) {\n      const vertex = vertices2[i];\n      const vertexCopy = vertex.clone();\n      if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);\n      vertices1.push(vertexCopy);\n    } // colors\n\n\n    for (let i = 0, il = colors2.length; i < il; i++) {\n      colors1.push(colors2[i].clone());\n    } // faces\n\n\n    for (let i = 0, il = faces2.length; i < il; i++) {\n      const face = faces2[i];\n      let normal, color;\n      const faceVertexNormals = face.vertexNormals,\n            faceVertexColors = face.vertexColors;\n      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n      faceCopy.normal.copy(face.normal);\n\n      if (normalMatrix !== undefined) {\n        faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n      }\n\n      for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n        normal = faceVertexNormals[j].clone();\n\n        if (normalMatrix !== undefined) {\n          normal.applyMatrix3(normalMatrix).normalize();\n        }\n\n        faceCopy.vertexNormals.push(normal);\n      }\n\n      faceCopy.color.copy(face.color);\n\n      for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {\n        color = faceVertexColors[j];\n        faceCopy.vertexColors.push(color.clone());\n      }\n\n      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n      faces1.push(faceCopy);\n    } // uvs\n\n\n    for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs2 = geometry.faceVertexUvs[i];\n      if (this.faceVertexUvs[i] === undefined) this.faceVertexUvs[i] = [];\n\n      for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n        const uvs2 = faceVertexUvs2[j],\n              uvsCopy = [];\n\n        for (let k = 0, kl = uvs2.length; k < kl; k++) {\n          uvsCopy.push(uvs2[k].clone());\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    }\n  }\n\n  mergeMesh(mesh) {\n    if (!(mesh && mesh.isMesh)) {\n      console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);\n      return;\n    }\n\n    if (mesh.matrixAutoUpdate) mesh.updateMatrix();\n    this.merge(mesh.geometry, mesh.matrix);\n  }\n  /*\n   * Checks for duplicate vertices with hashmap.\n   * Duplicated vertices are removed\n   * and faces' vertices are updated.\n   */\n\n\n  mergeVertices(precisionPoints = 4) {\n    const verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\n    const unique = [],\n          changes = [];\n    const precision = Math.pow(10, precisionPoints);\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const v = this.vertices[i];\n      const key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`;\n\n      if (verticesMap[key] === undefined) {\n        verticesMap[key] = i;\n        unique.push(this.vertices[i]);\n        changes[i] = unique.length - 1;\n      } else {\n        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n        changes[i] = changes[verticesMap[key]];\n      }\n    } // if faces are completely degenerate after merging vertices, we\n    // have to remove them from the geometry.\n\n\n    const faceIndicesToRemove = [];\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i];\n      face.a = changes[face.a];\n      face.b = changes[face.b];\n      face.c = changes[face.c];\n      const indices = [face.a, face.b, face.c]; // if any duplicate vertices are found in a Face3\n      // we have to remove the face as nothing can be saved\n\n      for (let n = 0; n < 3; n++) {\n        if (indices[n] === indices[(n + 1) % 3]) {\n          faceIndicesToRemove.push(i);\n          break;\n        }\n      }\n    }\n\n    for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n      const idx = faceIndicesToRemove[i];\n      this.faces.splice(idx, 1);\n\n      for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n        this.faceVertexUvs[j].splice(idx, 1);\n      }\n    } // Use unique set of vertices\n\n\n    const diff = this.vertices.length - unique.length;\n    this.vertices = unique;\n    return diff;\n  }\n\n  setFromPoints(points) {\n    this.vertices = [];\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));\n    }\n\n    return this;\n  }\n\n  sortFacesByMaterialIndex() {\n    const faces = this.faces;\n    const length = faces.length; // tag faces\n\n    for (let i = 0; i < length; i++) {\n      faces[i]._id = i;\n    } // sort faces\n\n\n    function materialIndexSort(a, b) {\n      return a.materialIndex - b.materialIndex;\n    }\n\n    faces.sort(materialIndexSort); // sort uvs\n\n    const uvs1 = this.faceVertexUvs[0];\n    const uvs2 = this.faceVertexUvs[1];\n    let newUvs1, newUvs2;\n    if (uvs1 && uvs1.length === length) newUvs1 = [];\n    if (uvs2 && uvs2.length === length) newUvs2 = [];\n\n    for (let i = 0; i < length; i++) {\n      const id = faces[i]._id;\n      if (newUvs1) newUvs1.push(uvs1[id]);\n      if (newUvs2) newUvs2.push(uvs2[id]);\n    }\n\n    if (newUvs1) this.faceVertexUvs[0] = newUvs1;\n    if (newUvs2) this.faceVertexUvs[1] = newUvs2;\n  }\n\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Geometry',\n        generator: 'Geometry.toJSON'\n      }\n    }; // standard Geometry serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n\n    if (this.parameters !== undefined) {\n      const parameters = this.parameters;\n\n      for (let key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key];\n      }\n\n      return data;\n    }\n\n    const vertices = [];\n\n    for (let i = 0; i < this.vertices.length; i++) {\n      const vertex = this.vertices[i];\n      vertices.push(vertex.x, vertex.y, vertex.z);\n    }\n\n    const faces = [];\n    const normals = [];\n    const normalsHash = {};\n    const colors = [];\n    const colorsHash = {};\n    const uvs = [];\n    const uvsHash = {};\n\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i];\n      const hasMaterial = true;\n      const hasFaceUv = false; // deprecated\n\n      const hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;\n      const hasFaceNormal = face.normal.length() > 0;\n      const hasFaceVertexNormal = face.vertexNormals.length > 0;\n      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n      const hasFaceVertexColor = face.vertexColors.length > 0;\n      let faceType = 0;\n      faceType = setBit(faceType, 0, 0); // isQuad\n\n      faceType = setBit(faceType, 1, hasMaterial);\n      faceType = setBit(faceType, 2, hasFaceUv);\n      faceType = setBit(faceType, 3, hasFaceVertexUv);\n      faceType = setBit(faceType, 4, hasFaceNormal);\n      faceType = setBit(faceType, 5, hasFaceVertexNormal);\n      faceType = setBit(faceType, 6, hasFaceColor);\n      faceType = setBit(faceType, 7, hasFaceVertexColor);\n      faces.push(faceType);\n      faces.push(face.a, face.b, face.c);\n      faces.push(face.materialIndex);\n\n      if (hasFaceVertexUv) {\n        const faceVertexUvs = this.faceVertexUvs[0][i];\n        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n      }\n\n      if (hasFaceNormal) {\n        faces.push(getNormalIndex(face.normal));\n      }\n\n      if (hasFaceVertexNormal) {\n        const vertexNormals = face.vertexNormals;\n        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n      }\n\n      if (hasFaceColor) {\n        faces.push(getColorIndex(face.color));\n      }\n\n      if (hasFaceVertexColor) {\n        const vertexColors = face.vertexColors;\n        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n      }\n    }\n\n    function setBit(value, position, enabled) {\n      return enabled ? value | 1 << position : value & ~(1 << position);\n    }\n\n    function getNormalIndex(normal) {\n      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n      if (normalsHash[hash] !== undefined) {\n        return normalsHash[hash];\n      }\n\n      normalsHash[hash] = normals.length / 3;\n      normals.push(normal.x, normal.y, normal.z);\n      return normalsHash[hash];\n    }\n\n    function getColorIndex(color) {\n      const hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n      if (colorsHash[hash] !== undefined) {\n        return colorsHash[hash];\n      }\n\n      colorsHash[hash] = colors.length;\n      colors.push(color.getHex());\n      return colorsHash[hash];\n    }\n\n    function getUvIndex(uv) {\n      const hash = uv.x.toString() + uv.y.toString();\n\n      if (uvsHash[hash] !== undefined) {\n        return uvsHash[hash];\n      }\n\n      uvsHash[hash] = uvs.length / 2;\n      uvs.push(uv.x, uv.y);\n      return uvsHash[hash];\n    }\n\n    data.data = {};\n    data.data.vertices = vertices;\n    data.data.normals = normals;\n    if (colors.length > 0) data.data.colors = colors;\n    if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility\n\n    data.data.faces = faces;\n    return data;\n  }\n\n  clone() {\n    /*\n    // Handle primitives\n    const parameters = this.parameters;\n    if ( parameters !== undefined ) {\n    const values = [];\n    for ( const key in parameters ) {\n    values.push( parameters[ key ] );\n    }\n    const geometry = Object.create( this.constructor.prototype );\n    this.constructor.apply( geometry, values );\n    return geometry;\n    }\n    return new this.constructor().copy( this );\n    */\n    return new Geometry().copy(this);\n  }\n\n  copy(source) {\n    // reset\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n    this.morphTargets = [];\n    this.morphNormals = [];\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.lineDistances = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // name\n\n    this.name = source.name; // vertices\n\n    const vertices = source.vertices;\n\n    for (let i = 0, il = vertices.length; i < il; i++) {\n      this.vertices.push(vertices[i].clone());\n    } // colors\n\n\n    const colors = source.colors;\n\n    for (let i = 0, il = colors.length; i < il; i++) {\n      this.colors.push(colors[i].clone());\n    } // faces\n\n\n    const faces = source.faces;\n\n    for (let i = 0, il = faces.length; i < il; i++) {\n      this.faces.push(faces[i].clone());\n    } // face vertex uvs\n\n\n    for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs = source.faceVertexUvs[i];\n\n      if (this.faceVertexUvs[i] === undefined) {\n        this.faceVertexUvs[i] = [];\n      }\n\n      for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n        const uvs = faceVertexUvs[j],\n              uvsCopy = [];\n\n        for (let k = 0, kl = uvs.length; k < kl; k++) {\n          const uv = uvs[k];\n          uvsCopy.push(uv.clone());\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy);\n      }\n    } // morph targets\n\n\n    const morphTargets = source.morphTargets;\n\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = {};\n      morphTarget.name = morphTargets[i].name; // vertices\n\n      if (morphTargets[i].vertices !== undefined) {\n        morphTarget.vertices = [];\n\n        for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\n        }\n      } // normals\n\n\n      if (morphTargets[i].normals !== undefined) {\n        morphTarget.normals = [];\n\n        for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n          morphTarget.normals.push(morphTargets[i].normals[j].clone());\n        }\n      }\n\n      this.morphTargets.push(morphTarget);\n    } // morph normals\n\n\n    const morphNormals = source.morphNormals;\n\n    for (let i = 0, il = morphNormals.length; i < il; i++) {\n      const morphNormal = {}; // vertex normals\n\n      if (morphNormals[i].vertexNormals !== undefined) {\n        morphNormal.vertexNormals = [];\n\n        for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n          const srcVertexNormal = morphNormals[i].vertexNormals[j];\n          const destVertexNormal = {};\n          destVertexNormal.a = srcVertexNormal.a.clone();\n          destVertexNormal.b = srcVertexNormal.b.clone();\n          destVertexNormal.c = srcVertexNormal.c.clone();\n          morphNormal.vertexNormals.push(destVertexNormal);\n        }\n      } // face normals\n\n\n      if (morphNormals[i].faceNormals !== undefined) {\n        morphNormal.faceNormals = [];\n\n        for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\n        }\n      }\n\n      this.morphNormals.push(morphNormal);\n    } // skin weights\n\n\n    const skinWeights = source.skinWeights;\n\n    for (let i = 0, il = skinWeights.length; i < il; i++) {\n      this.skinWeights.push(skinWeights[i].clone());\n    } // skin indices\n\n\n    const skinIndices = source.skinIndices;\n\n    for (let i = 0, il = skinIndices.length; i < il; i++) {\n      this.skinIndices.push(skinIndices[i].clone());\n    } // line distances\n\n\n    const lineDistances = source.lineDistances;\n\n    for (let i = 0, il = lineDistances.length; i < il; i++) {\n      this.lineDistances.push(lineDistances[i]);\n    } // bounding box\n\n\n    const boundingBox = source.boundingBox;\n\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    } // bounding sphere\n\n\n    const boundingSphere = source.boundingSphere;\n\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    } // update flags\n\n\n    this.elementsNeedUpdate = source.elementsNeedUpdate;\n    this.verticesNeedUpdate = source.verticesNeedUpdate;\n    this.uvsNeedUpdate = source.uvsNeedUpdate;\n    this.normalsNeedUpdate = source.normalsNeedUpdate;\n    this.colorsNeedUpdate = source.colorsNeedUpdate;\n    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n    this.groupsNeedUpdate = source.groupsNeedUpdate;\n    return this;\n  }\n\n  toBufferGeometry() {\n    const geometry = new DirectGeometry().fromGeometry(this);\n    const buffergeometry = new BufferGeometry();\n    const positions = new Float32Array(geometry.vertices.length * 3);\n    buffergeometry.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n\n    if (geometry.normals.length > 0) {\n      const normals = new Float32Array(geometry.normals.length * 3);\n      buffergeometry.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n    }\n\n    if (geometry.colors.length > 0) {\n      const colors = new Float32Array(geometry.colors.length * 3);\n      buffergeometry.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n    }\n\n    if (geometry.uvs.length > 0) {\n      const uvs = new Float32Array(geometry.uvs.length * 2);\n      buffergeometry.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n    }\n\n    if (geometry.uvs2.length > 0) {\n      const uvs2 = new Float32Array(geometry.uvs2.length * 2);\n      buffergeometry.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n    } // groups\n\n\n    buffergeometry.groups = geometry.groups; // morphs\n\n    for (let name in geometry.morphTargets) {\n      const array = [];\n      const morphTargets = geometry.morphTargets[name];\n\n      for (let i = 0, l = morphTargets.length; i < l; i++) {\n        const morphTarget = morphTargets[i];\n        const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\n        attribute.name = morphTarget.name;\n        array.push(attribute.copyVector3sArray(morphTarget.data));\n      }\n\n      buffergeometry.morphAttributes[name] = array;\n    } // skinning\n\n\n    if (geometry.skinIndices.length > 0) {\n      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n      buffergeometry.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));\n    }\n\n    if (geometry.skinWeights.length > 0) {\n      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n      buffergeometry.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));\n    } //\n\n\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n\n    return buffergeometry;\n  }\n\n  computeTangents() {\n    console.error('THREE.Geometry: .computeTangents() has been removed.');\n  }\n\n  computeLineDistances() {\n    console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().');\n    return this.applyMatrix4(matrix);\n  }\n\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n\n}\n\nGeometry.createBufferGeometryFromObject = object => {\n  let buffergeometry = new BufferGeometry();\n  const geometry = object.geometry;\n\n  if (object.isPoints || object.isLine) {\n    const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\n    const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\n    buffergeometry.setAttribute('position', positions.copyVector3sArray(geometry.vertices));\n    buffergeometry.setAttribute('color', colors.copyColorsArray(geometry.colors));\n\n    if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n      const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\n      buffergeometry.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));\n    }\n\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n  } else if (object.isMesh) {\n    buffergeometry = geometry.toBufferGeometry();\n  }\n\n  return buffergeometry;\n};\n\nclass DirectGeometry {\n  constructor() {\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n    this.uvs2 = [];\n    this.groups = [];\n    this.morphTargets = {};\n    this.skinWeights = [];\n    this.skinIndices = []; // this.lineDistances = [];\n\n    this.boundingBox = null;\n    this.boundingSphere = null; // update flags\n\n    this.verticesNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n\n  computeGroups(geometry) {\n    const groups = [];\n    let group, i;\n    let materialIndex = undefined;\n    const faces = geometry.faces;\n\n    for (i = 0; i < faces.length; i++) {\n      const face = faces[i]; // materials\n\n      if (face.materialIndex !== materialIndex) {\n        materialIndex = face.materialIndex;\n\n        if (group !== undefined) {\n          group.count = i * 3 - group.start;\n          groups.push(group);\n        }\n\n        group = {\n          start: i * 3,\n          materialIndex\n        };\n      }\n    }\n\n    if (group !== undefined) {\n      group.count = i * 3 - group.start;\n      groups.push(group);\n    }\n\n    this.groups = groups;\n  }\n\n  fromGeometry(geometry) {\n    const faces = geometry.faces;\n    const vertices = geometry.vertices;\n    const faceVertexUvs = geometry.faceVertexUvs;\n    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0; // morphs\n\n    const morphTargets = geometry.morphTargets;\n    const morphTargetsLength = morphTargets.length;\n    let morphTargetsPosition;\n\n    if (morphTargetsLength > 0) {\n      morphTargetsPosition = [];\n\n      for (let i = 0; i < morphTargetsLength; i++) {\n        morphTargetsPosition[i] = {\n          name: morphTargets[i].name,\n          data: []\n        };\n      }\n\n      this.morphTargets.position = morphTargetsPosition;\n    }\n\n    const morphNormals = geometry.morphNormals;\n    const morphNormalsLength = morphNormals.length;\n    let morphTargetsNormal;\n\n    if (morphNormalsLength > 0) {\n      morphTargetsNormal = [];\n\n      for (let i = 0; i < morphNormalsLength; i++) {\n        morphTargetsNormal[i] = {\n          name: morphNormals[i].name,\n          data: []\n        };\n      }\n\n      this.morphTargets.normal = morphTargetsNormal;\n    } // skins\n\n\n    const skinIndices = geometry.skinIndices;\n    const skinWeights = geometry.skinWeights;\n    const hasSkinIndices = skinIndices.length === vertices.length;\n    const hasSkinWeights = skinWeights.length === vertices.length; //\n\n    if (vertices.length > 0 && faces.length === 0) {\n      console.error('THREE.DirectGeometry: Faceless geometries are not supported.');\n    }\n\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n      const vertexNormals = face.vertexNormals;\n\n      if (vertexNormals.length === 3) {\n        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n      } else {\n        const normal = face.normal;\n        this.normals.push(normal, normal, normal);\n      }\n\n      const vertexColors = face.vertexColors;\n\n      if (vertexColors.length === 3) {\n        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n      } else {\n        const color = face.color;\n        this.colors.push(color, color, color);\n      }\n\n      if (hasFaceVertexUv === true) {\n        const vertexUvs = faceVertexUvs[0][i];\n\n        if (vertexUvs !== undefined) {\n          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);\n          this.uvs.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      }\n\n      if (hasFaceVertexUv2 === true) {\n        const vertexUvs = faceVertexUvs[1][i];\n\n        if (vertexUvs !== undefined) {\n          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);\n          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());\n        }\n      } // morphs\n\n\n      for (let j = 0; j < morphTargetsLength; j++) {\n        const morphTarget = morphTargets[j].vertices;\n        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n      }\n\n      for (let j = 0; j < morphNormalsLength; j++) {\n        const morphNormal = morphNormals[j].vertexNormals[i];\n        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n      } // skins\n\n\n      if (hasSkinIndices) {\n        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n      }\n\n      if (hasSkinWeights) {\n        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n      }\n    }\n\n    this.computeGroups(geometry);\n    this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n    this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n    this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n    this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n    this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone();\n    }\n\n    return this;\n  }\n\n}\n\nclass Face3 {\n  constructor(a, b, c, normal, color, materialIndex = 0) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = normal && normal.isVector3 ? normal : new Vector3();\n    this.vertexNormals = Array.isArray(normal) ? normal : [];\n    this.color = color && color.isColor ? color : new Color();\n    this.vertexColors = Array.isArray(color) ? color : [];\n    this.materialIndex = materialIndex;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(source) {\n    this.a = source.a;\n    this.b = source.b;\n    this.c = source.c;\n    this.normal.copy(source.normal);\n    this.color.copy(source.color);\n    this.materialIndex = source.materialIndex;\n\n    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {\n      this.vertexNormals[i] = source.vertexNormals[i].clone();\n    }\n\n    for (let i = 0, il = source.vertexColors.length; i < il; i++) {\n      this.vertexColors[i] = source.vertexColors[i].clone();\n    }\n\n    return this;\n  }\n\n}\n\nexport { Face3, Geometry };\n","import { Suspense, useMemo } from 'react'\nimport * as THREE from 'three'\nimport { Canvas } from '@react-three/fiber'\nimport { useGLTF } from '@react-three/drei'\nimport { Physics, useConvexPolyhedron, usePlane } from '@react-three/cannon'\nimport { Geometry } from 'three-stdlib'\n\nimport model from '../../models/diamond.glb'\n\n/**\n * Returns legacy geometry vertices, faces for ConvP\n * @param {THREE.BufferGeometry} bufferGeometry\n */\nconst toConvexProps = (bufferGeometry: THREE.BufferGeometry) => {\n  const geo = new Geometry().fromBufferGeometry(bufferGeometry)\n  \n  // Merge duplicate vertices resulting from glTF export.\n  // Cannon assumes contiguous, closed meshes to work\n  geo.mergeVertices()\n\n  return [\n    geo.vertices.map((v) => [v.x, v.y, v.z]),\n    geo.faces.map((f) => [f.a, f.b, f.c]),\n    []\n  ]\n}\n\nconst Diamond = (props: any) => {\n  const { nodes }: any = useGLTF(model)\n  const geo = useMemo(() => toConvexProps(nodes.Cylinder.geometry), [nodes])\n  const [ref]: any[] = useConvexPolyhedron(() => ({ mass: 100, ...props, args: geo }))\n\n  return (\n    <mesh castShadow receiveShadow ref={ref} geometry={nodes.Cylinder.geometry} {...props}>\n      <meshStandardMaterial wireframe color='white' />\n    </mesh>\n  )\n}\n\n// A cone is a convex shape by definition...\nconst Cone = ({ sides, ...props }: any) => {\n  const geo = useMemo(\n    () => toConvexProps(new THREE.ConeGeometry(0.7, 0.7, sides, 1)),\n    []\n  )\n  const [ref]: any[] = useConvexPolyhedron(() => ({ mass: 100, ...props, args: geo }))\n\n  return (\n    <mesh castShadow ref={ref} {...props}>\n      <coneGeometry args={[0.7, 0.7, sides, 1]} />\n      <meshNormalMaterial />\n    </mesh>\n  )\n}\n\n// ...And so is cube!\nconst Cube = ({ size, ...props }: any) => {\n  // note, this is wildly inefficient vs useBox\n  const geo = useMemo(\n    () => toConvexProps(new THREE.BoxGeometry(size, size, size)),\n    []\n  )\n  const [ref]: any[] = useConvexPolyhedron(() => ({ mass: 100, ...props, args: geo }))\n\n  return (\n    <mesh castShadow receiveShadow ref={ref} {...props} geometry={geo} >\n      <boxGeometry args={[size, size, size]} />\n      <meshPhysicalMaterial color='rebeccapurple' />\n    </mesh>\n  )\n}\n\nconst Plane = (props: any) => {\n  const [ref]: any[] = usePlane(() => ({ type: 'Static', ...props }))\n  \n  return (\n    <mesh ref={ref} receiveShadow>\n      <planeGeometry args={[10, 10]} />\n      <shadowMaterial color='#171717' />\n    </mesh>\n  )\n}\n\nconst Example = ({ children }: any) => {\n  return (\n    <>\n      { children }\n      <Canvas shadows dpr={[1, 2]} camera={{ position: [-1, 1, 5], fov: 50}} >\n        <color attach='background' args={['lightpink']} />\n        <spotLight position={[15, 15, 15]} angle={0.3} penumbra={1} intensity={2}\n          castShadow shadow-mapSize={[2048, 2048]} />\n        <Suspense fallback={null}>\n          <Physics>\n            <Plane rotation={[-Math.PI / 2, 0, 0]} />\n            <Diamond position={[1, 5, 0]} rotation={[0.4, 0.1, 0.1]} />\n            <Cone position={[-1, 5, 0.5]} rotation={[0.1, 0.2, 0.1]} sides={6} />\n            <Cone position={[-1, 6, 0]} rotation={[0.5, 0.1, 0.1]} sides={8} />\n            <Cube position={[2, 3, -0.3]} rotation={[0.5, 0.4, -1]} size={0.4} />\n            <Cone position={[-0.3, 7, 1]} rotation={[1, 0.4, 0.1]} sides={7} />\n          </Physics>\n        </Suspense>\n      </Canvas>\n    </>\n  )\n}\n\nexport default Example"],"names":["_m1","Matrix4","_obj","Object3D","_offset","Vector3","Geometry","isGeometry","uuid","MathUtils","name","type","vertices","colors","faces","faceVertexUvs","morphTargets","morphNormals","skinWeights","skinIndices","lineDistances","boundingBox","boundingSphere","elementsNeedUpdate","verticesNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","matrix","normalMatrix","Matrix3","getNormalMatrix","i","il","this","length","applyMatrix4","face","normal","applyMatrix3","normalize","j","jl","vertexNormals","computeBoundingBox","computeBoundingSphere","angle","makeRotationX","makeRotationY","makeRotationZ","x","y","z","makeTranslation","makeScale","vector","lookAt","updateMatrix","geometry","scope","index","undefined","attributes","position","console","error","color","uv","uv2","count","push","fromBufferAttribute","Color","addFace","a","b","c","materialIndex","vertexColors","clone","Face3","Vector2","groups","group","start","getX","computeFaceNormals","getCenter","negate","translate","center","radius","s","set","cb","ab","f","fl","vA","vB","vC","subVectors","cross","copy","areaWeighted","Array","v","vl","add","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","dstNormalsFace","dstNormalsVertex","faceNormal","computeVertexNormals","Box3","setFromPoints","Sphere","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","colors1","colors2","vertex","vertexCopy","faceVertexNormals","faceVertexColors","faceCopy","faceVertexUvs2","uvs2","uvsCopy","k","kl","mesh","isMesh","matrixAutoUpdate","merge","precisionPoints","verticesMap","unique","changes","precision","Math","pow","key","round","faceIndicesToRemove","indices","n","idx","splice","diff","points","l","point","_id","sort","newUvs1","newUvs2","uvs1","id","data","metadata","version","generator","parameters","normals","normalsHash","colorsHash","uvs","uvsHash","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","r","g","hasFaceVertexColor","faceType","setBit","getUvIndex","getNormalIndex","getColorIndex","value","enabled","hash","toString","getHex","source","morphTarget","morphNormal","srcVertexNormal","destVertexNormal","DirectGeometry","fromGeometry","buffergeometry","BufferGeometry","positions","Float32Array","setAttribute","BufferAttribute","copyVector3sArray","copyColorsArray","copyVector2sArray","array","attribute","Float32BufferAttribute","morphAttributes","copyVector4sArray","warn","dispatchEvent","EventDispatcher","createBufferGeometryFromObject","object","isPoints","isLine","copyArray","toBufferGeometry","morphTargetsPosition","hasFaceVertexUv2","morphTargetsLength","morphTargetsNormal","morphNormalsLength","hasSkinIndices","hasSkinWeights","vertexUvs","computeGroups","isVector3","isArray","isColor","constructor","toConvexProps","bufferGeometry","geo","fromBufferGeometry","mergeVertices","map","Diamond","props","nodes","useGLTF","model","useMemo","Cylinder","useConvexPolyhedron","mass","args","ref","castShadow","receiveShadow","wireframe","Cone","sides","THREE","Cube","size","Plane","usePlane","children","shadows","dpr","camera","fov","attach","penumbra","intensity","Suspense","fallback","rotation","PI"],"sourceRoot":""}