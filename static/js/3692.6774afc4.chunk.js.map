{"version":3,"file":"static/js/3692.6774afc4.chunk.js","mappings":"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","sources":["../node_modules/three-stdlib/objects/Water.js","basic-examples/water-shader/Example.tsx","../node_modules/@react-three/drei/core/OrbitControls.js","../node_modules/three-stdlib/objects/Sky.js","../node_modules/@react-three/drei/core/Sky.js"],"sourcesContent":["import { Mesh, Vector3, Color, FrontSide, Plane, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, UniformsUtils, UniformsLib, ShaderMaterial } from 'three';\n\n/**\n * Work based on :\n * https://github.com/Slayvin: Flat mirror for three.js\n * https://home.adelphi.edu/~stemkoski/ : An implementation of water shader based on the flat mirror\n * http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\n */\n\nclass Water extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    const scope = this;\n    const textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\n    const textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\n    const clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\n    const alpha = options.alpha !== undefined ? options.alpha : 1.0;\n    const time = options.time !== undefined ? options.time : 0.0;\n    const normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;\n    const sunDirection = options.sunDirection !== undefined ? options.sunDirection : new Vector3(0.70707, 0.70707, 0.0);\n    const sunColor = new Color(options.sunColor !== undefined ? options.sunColor : 0xffffff);\n    const waterColor = new Color(options.waterColor !== undefined ? options.waterColor : 0x7f7f7f);\n    const eye = options.eye !== undefined ? options.eye : new Vector3(0, 0, 0);\n    const distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;\n    const side = options.side !== undefined ? options.side : FrontSide;\n    const fog = options.fog !== undefined ? options.fog : false; //\n\n    const mirrorPlane = new Plane();\n    const normal = new Vector3();\n    const mirrorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const clipPlane = new Vector4();\n    const view = new Vector3();\n    const target = new Vector3();\n    const q = new Vector4();\n    const textureMatrix = new Matrix4();\n    const mirrorCamera = new PerspectiveCamera();\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);\n    const mirrorShader = {\n      uniforms: UniformsUtils.merge([UniformsLib['fog'], UniformsLib['lights'], {\n        normalSampler: {\n          value: null\n        },\n        mirrorSampler: {\n          value: null\n        },\n        alpha: {\n          value: 1.0\n        },\n        time: {\n          value: 0.0\n        },\n        size: {\n          value: 1.0\n        },\n        distortionScale: {\n          value: 20.0\n        },\n        textureMatrix: {\n          value: new Matrix4()\n        },\n        sunColor: {\n          value: new Color(0x7f7f7f)\n        },\n        sunDirection: {\n          value: new Vector3(0.70707, 0.70707, 0)\n        },\n        eye: {\n          value: new Vector3()\n        },\n        waterColor: {\n          value: new Color(0x555555)\n        }\n      }]),\n      vertexShader:\n      /* glsl */\n      `\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}`,\n      fragmentShader:\n      /* glsl */\n      `\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float distortionScale;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <shadowmask_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t}`\n    };\n    const material = new ShaderMaterial({\n      fragmentShader: mirrorShader.fragmentShader,\n      vertexShader: mirrorShader.vertexShader,\n      uniforms: UniformsUtils.clone(mirrorShader.uniforms),\n      lights: true,\n      side: side,\n      fog: fog\n    });\n    material.uniforms['mirrorSampler'].value = renderTarget.texture;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n    material.uniforms['alpha'].value = alpha;\n    material.uniforms['time'].value = time;\n    material.uniforms['normalSampler'].value = normalSampler;\n    material.uniforms['sunColor'].value = sunColor;\n    material.uniforms['waterColor'].value = waterColor;\n    material.uniforms['sunDirection'].value = sunDirection;\n    material.uniforms['distortionScale'].value = distortionScale;\n    material.uniforms['eye'].value = eye;\n    scope.material = material;\n\n    scope.onBeforeRender = function (renderer, scene, camera) {\n      mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(mirrorWorldPosition, cameraWorldPosition); // Avoid rendering when mirror is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(mirrorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(mirrorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(mirrorWorldPosition);\n      mirrorCamera.position.copy(view);\n      mirrorCamera.up.set(0, 1, 0);\n      mirrorCamera.up.applyMatrix4(rotationMatrix);\n      mirrorCamera.up.reflect(normal);\n      mirrorCamera.lookAt(target);\n      mirrorCamera.far = camera.far; // Used in WebGLBackground\n\n      mirrorCamera.updateMatrixWorld();\n      mirrorCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(mirrorCamera.projectionMatrix);\n      textureMatrix.multiply(mirrorCamera.matrixWorldInverse); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n      mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);\n      mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);\n      clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);\n      const projectionMatrix = mirrorCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1.0;\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n      eye.setFromMatrixPosition(camera.matrixWorld); // Render\n\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      scope.visible = false;\n      renderer.xr.enabled = false; // Avoid camera modification and recursion\n\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, mirrorCamera);\n      scope.visible = true;\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n      const viewport = camera.viewport;\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n    };\n  }\n\n}\n\nWater.prototype.isWater = true;\n\nexport { Water };\n","import { Suspense, useMemo, useRef } from 'react'\nimport * as THREE from 'three'\nimport { Canvas, extend, Object3DNode, useFrame, useLoader, useThree } from '@react-three/fiber'\nimport { Water } from 'three-stdlib'\n\nimport water from '../../textures/waternormals.jpeg'\nimport { OrbitControls, Sky } from '@react-three/drei'\n\nextend({ Water })\ndeclare global {\n  namespace JSX {\n    interface IntrinsicElements {\n      water: Object3DNode<any, typeof Water>\n    }\n  }\n}\n\nconst Ocean = () => {\n  const ref: any = useRef()\n  const gl: any = useThree((state) => state.gl)\n  const waterNormals = useLoader(THREE.TextureLoader, water)\n  waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping\n  const geom = useMemo(() => new THREE.PlaneGeometry(10000, 10000), [])\n  const config = useMemo(\n    () => ({\n      textureWidth: 512,\n      textureHeight: 512,\n      waterNormals,\n      sunDirection: new THREE.Vector3(),\n      sunColor: 0xffffff,\n      waterColor: 0x001e0f,\n      distortionScale: 3.7,\n      fog: false,\n      format: gl.encoding\n    }),\n    [waterNormals]\n  )\n  useFrame((_, delta) => (ref.current.material.uniforms.time.value += delta))\n  return <water ref={ref} args={[geom, config]} rotation-x={-Math.PI / 2} />\n}\n\nconst Box = () => {\n  const ref: any = useRef()\n  useFrame((state, delta) => {\n    ref.current.position.y = 10 + Math.sin(state.clock.elapsedTime) * 20\n    ref.current.rotation.x = ref.current.rotation.y = ref.current.rotation.z += delta\n  })\n  return (\n    <mesh ref={ref} scale={20}>\n      <boxGeometry />\n      <meshStandardMaterial />\n    </mesh>\n  )\n}\n\nconst Example = ({ children }: any) => {\n  return (\n    <>\n      { children }\n      <Canvas camera={{ position: [0, 5, 100], fov: 55, near: 1, far: 20000 }}>\n        <pointLight position={[100, 100, 100]} />\n        <pointLight position={[-100, -100, -100]} />\n        <Suspense fallback={null}>\n          <Ocean />\n          <Box />\n        </Suspense>\n        <Sky sunPosition={[500, 150, -1000]} turbidity={0.1} />\n        <OrbitControls />\n      </Canvas>\n    </>\n  )\n}\n\nexport default Example","import _extends from '@babel/runtime/helpers/esm/extends';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport * as React from 'react';\nimport { OrbitControls as OrbitControls$1 } from 'three-stdlib';\n\nconst OrbitControls = /*#__PURE__*/React.forwardRef(({\n  makeDefault,\n  camera,\n  regress,\n  domElement,\n  enableDamping = true,\n  onChange,\n  onStart,\n  onEnd,\n  ...restProps\n}, ref) => {\n  const invalidate = useThree(state => state.invalidate);\n  const defaultCamera = useThree(state => state.camera);\n  const gl = useThree(state => state.gl);\n  const events = useThree(state => state.events);\n  const set = useThree(state => state.set);\n  const get = useThree(state => state.get);\n  const performance = useThree(state => state.performance);\n  const explCamera = camera || defaultCamera;\n  const explDomElement = domElement || events.connected || gl.domElement;\n  const controls = React.useMemo(() => new OrbitControls$1(explCamera), [explCamera]);\n  useFrame(() => {\n    if (controls.enabled) controls.update();\n  }, -1);\n  React.useEffect(() => {\n    controls.connect(explDomElement);\n    return () => void controls.dispose();\n  }, [explDomElement, regress, controls, invalidate]);\n  React.useEffect(() => {\n    const callback = e => {\n      invalidate();\n      if (regress) performance.regress();\n      if (onChange) onChange(e);\n    };\n\n    controls.addEventListener('change', callback);\n    if (onStart) controls.addEventListener('start', onStart);\n    if (onEnd) controls.addEventListener('end', onEnd);\n    return () => {\n      if (onStart) controls.removeEventListener('start', onStart);\n      if (onEnd) controls.removeEventListener('end', onEnd);\n      controls.removeEventListener('change', callback);\n    };\n  }, [onChange, onStart, onEnd]);\n  React.useEffect(() => {\n    if (makeDefault) {\n      const old = get().controls;\n      set({\n        controls\n      });\n      return () => set({\n        controls: old\n      });\n    }\n  }, [makeDefault, controls]);\n  return /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    ref: ref,\n    object: controls,\n    enableDamping: enableDamping\n  }, restProps));\n});\n\nexport { OrbitControls };\n","import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Mesh, BoxGeometry, Vector3, ShaderMaterial, UniformsUtils, BackSide } from 'three';\n\n/**\n * Based on \"A Practical Analytic Model for Daylight\"\n * aka The Preetham Model, the de facto standard analytic skydome model\n * https://www.researchgate.net/publication/220720443_A_Practical_Analytic_Model_for_Daylight\n *\n * First implemented by Simon Wallner\n * http://www.simonwallner.at/projects/atmospheric-scattering\n *\n * Improved by Martin Upitis\n * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR\n *\n * Three.js integration by zz85 http://twitter.com/blurspline\n */\n\nclass Sky extends Mesh {\n  constructor() {\n    super(new BoxGeometry(1, 1, 1), Sky.material);\n  }\n\n}\n\n_defineProperty(Sky, \"SkyShader\", {\n  uniforms: {\n    turbidity: {\n      value: 2\n    },\n    rayleigh: {\n      value: 1\n    },\n    mieCoefficient: {\n      value: 0.005\n    },\n    mieDirectionalG: {\n      value: 0.8\n    },\n    sunPosition: {\n      value: new Vector3()\n    },\n    up: {\n      value: new Vector3(0, 1, 0)\n    }\n  },\n  vertexShader: ['uniform vec3 sunPosition;', 'uniform float rayleigh;', 'uniform float turbidity;', 'uniform float mieCoefficient;', 'uniform vec3 up;', 'varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', // constants for atmospheric scattering\n  'const float e = 2.71828182845904523536028747135266249775724709369995957;', 'const float pi = 3.141592653589793238462643383279502884197169;', // wavelength of used primaries, according to preetham\n  'const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );', // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n  // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n  'const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );', // mie stuff\n  // K coefficient for the primaries\n  'const float v = 4.0;', 'const vec3 K = vec3( 0.686, 0.678, 0.666 );', // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n  'const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );', // earth shadow hack\n  // cutoffAngle = pi / 1.95;\n  'const float cutoffAngle = 1.6110731556870734;', 'const float steepness = 1.5;', 'const float EE = 1000.0;', 'float sunIntensity( float zenithAngleCos ) {', '\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );', '\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );', '}', 'vec3 totalMie( float T ) {', '\tfloat c = ( 0.2 * T ) * 10E-18;', '\treturn 0.434 * c * MieConst;', '}', 'void main() {', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tvWorldPosition = worldPosition.xyz;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '\tgl_Position.z = gl_Position.w;', // set z to camera.far\n  '\tvSunDirection = normalize( sunPosition );', '\tvSunE = sunIntensity( dot( vSunDirection, up ) );', '\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );', '\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );', // extinction (absorbtion + out scattering)\n  // rayleigh coefficients\n  '\tvBetaR = totalRayleigh * rayleighCoefficient;', // mie coefficients\n  '\tvBetaM = totalMie( turbidity ) * mieCoefficient;', '}'].join('\\n'),\n  fragmentShader: ['varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', 'uniform float mieDirectionalG;', 'uniform vec3 up;', 'const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );', // constants for atmospheric scattering\n  'const float pi = 3.141592653589793238462643383279502884197169;', 'const float n = 1.0003;', // refractive index of air\n  'const float N = 2.545E25;', // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n  // optical length at zenith for molecules\n  'const float rayleighZenithLength = 8.4E3;', 'const float mieZenithLength = 1.25E3;', // 66 arc seconds -> degrees, and the cosine of that\n  'const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;', // 3.0 / ( 16.0 * pi )\n  'const float THREE_OVER_SIXTEENPI = 0.05968310365946075;', // 1.0 / ( 4.0 * pi )\n  'const float ONE_OVER_FOURPI = 0.07957747154594767;', 'float rayleighPhase( float cosTheta ) {', '\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );', '}', 'float hgPhase( float cosTheta, float g ) {', '\tfloat g2 = pow( g, 2.0 );', '\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );', '\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );', '}', 'void main() {', '\tvec3 direction = normalize( vWorldPosition - cameraPos );', // optical length\n  // cutoff angle at 90 to avoid singularity in next formula.\n  '\tfloat zenithAngle = acos( max( 0.0, dot( up, direction ) ) );', '\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );', '\tfloat sR = rayleighZenithLength * inverse;', '\tfloat sM = mieZenithLength * inverse;', // combined extinction factor\n  '\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );', // in scattering\n  '\tfloat cosTheta = dot( direction, vSunDirection );', '\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );', '\tvec3 betaRTheta = vBetaR * rPhase;', '\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );', '\tvec3 betaMTheta = vBetaM * mPhase;', '\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );', '\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );', // nightsky\n  '\tfloat theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]', '\tfloat phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]', '\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );', '\tvec3 L0 = vec3( 0.1 ) * Fex;', // composition + solar disc\n  '\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );', '\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;', '\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );', '\tvec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );', '\tgl_FragColor = vec4( retColor, 1.0 );', '#include <tonemapping_fragment>', '#include <encodings_fragment>', '}'].join('\\n')\n});\n\n_defineProperty(Sky, \"material\", new ShaderMaterial({\n  name: 'SkyShader',\n  fragmentShader: Sky.SkyShader.fragmentShader,\n  vertexShader: Sky.SkyShader.vertexShader,\n  uniforms: UniformsUtils.clone(Sky.SkyShader.uniforms),\n  side: BackSide,\n  depthWrite: false\n}));\n\nexport { Sky };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { Sky as Sky$1 } from 'three-stdlib';\nimport { Vector3 } from 'three';\n\nfunction calcPosFromAngles(inclination, azimuth, vector = new Vector3()) {\n  const theta = Math.PI * (inclination - 0.5);\n  const phi = 2 * Math.PI * (azimuth - 0.5);\n  vector.x = Math.cos(phi);\n  vector.y = Math.sin(theta);\n  vector.z = Math.sin(phi);\n  return vector;\n}\nconst Sky = /*#__PURE__*/React.forwardRef(({\n  inclination = 0.6,\n  azimuth = 0.1,\n  distance = 1000,\n  mieCoefficient = 0.005,\n  mieDirectionalG = 0.8,\n  rayleigh = 0.5,\n  turbidity = 10,\n  sunPosition = calcPosFromAngles(inclination, azimuth),\n  ...props\n}, ref) => {\n  const scale = React.useMemo(() => new Vector3().setScalar(distance), [distance]);\n  const [sky] = React.useState(() => new Sky$1());\n  return /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    object: sky,\n    ref: ref,\n    \"material-uniforms-mieCoefficient-value\": mieCoefficient,\n    \"material-uniforms-mieDirectionalG-value\": mieDirectionalG,\n    \"material-uniforms-rayleigh-value\": rayleigh,\n    \"material-uniforms-sunPosition-value\": sunPosition,\n    \"material-uniforms-turbidity-value\": turbidity,\n    scale: scale\n  }, props));\n});\n\nexport { Sky, calcPosFromAngles };\n"],"names":["Water","geometry","options","scope","textureWidth","undefined","textureHeight","clipBias","alpha","time","normalSampler","waterNormals","sunDirection","Vector3","sunColor","Color","waterColor","eye","distortionScale","side","FrontSide","fog","mirrorPlane","Plane","normal","mirrorWorldPosition","cameraWorldPosition","rotationMatrix","Matrix4","lookAtPosition","clipPlane","Vector4","view","target","q","textureMatrix","mirrorCamera","PerspectiveCamera","renderTarget","WebGLRenderTarget","mirrorShader","uniforms","UniformsUtils","UniformsLib","value","mirrorSampler","size","vertexShader","fragmentShader","material","ShaderMaterial","lights","texture","onBeforeRender","renderer","scene","camera","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","visible","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","Mesh","prototype","isWater","extend","Ocean","ref","useRef","gl","useThree","useLoader","THREE","water","wrapS","wrapT","geom","useMemo","config","format","encoding","useFrame","_","delta","current","args","PI","Box","sin","clock","elapsedTime","rotation","scale","children","fov","near","Suspense","fallback","Sky","sunPosition","turbidity","OrbitControls","React","makeDefault","regress","domElement","enableDamping","onChange","onStart","onEnd","restProps","invalidate","defaultCamera","events","get","performance","explCamera","explDomElement","connected","controls","OrbitControls$1","update","connect","dispose","callback","e","addEventListener","removeEventListener","old","_extends","object","BoxGeometry","_defineProperty","rayleigh","mieCoefficient","mieDirectionalG","join","name","SkyShader","BackSide","depthWrite","inclination","azimuth","distance","vector","theta","phi","cos","calcPosFromAngles","props","setScalar","Sky$1","sky"],"sourceRoot":""}